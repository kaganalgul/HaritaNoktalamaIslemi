/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/webgl/ShaderBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ValueTypes,expressionToGlsl,getStringNumberEquivalent,uniformNameForVariable}from"../style/expressions.js";var ShaderBuilder=function(){function e(){this.uniforms=[],this.attributes=[],this.varyings=[],this.sizeExpression="vec2(1.0)",this.rotationExpression="0.0",this.offsetExpression="vec2(0.0)",this.colorExpression="vec4(1.0)",this.texCoordExpression="vec4(0.0, 0.0, 1.0, 1.0)",this.discardExpression="false",this.rotateWithView=!1}return e.prototype.addUniform=function(e){return this.uniforms.push(e),this},e.prototype.addAttribute=function(e){return this.attributes.push(e),this},e.prototype.addVarying=function(e,t,o){return this.varyings.push({name:e,type:t,expression:o}),this},e.prototype.setSizeExpression=function(e){return this.sizeExpression=e,this},e.prototype.setRotationExpression=function(e){return this.rotationExpression=e,this},e.prototype.setSymbolOffsetExpression=function(e){return this.offsetExpression=e,this},e.prototype.setColorExpression=function(e){return this.colorExpression=e,this},e.prototype.setTextureCoordinateExpression=function(e){return this.texCoordExpression=e,this},e.prototype.setFragmentDiscardExpression=function(e){return this.discardExpression=e,this},e.prototype.setSymbolRotateWithView=function(e){return this.rotateWithView=e,this},e.prototype.getSizeExpression=function(){return this.sizeExpression},e.prototype.getOffsetExpression=function(){return this.offsetExpression},e.prototype.getColorExpression=function(){return this.colorExpression},e.prototype.getTextureCoordinateExpression=function(){return this.texCoordExpression},e.prototype.getFragmentDiscardExpression=function(){return this.discardExpression},e.prototype.getSymbolVertexShader=function(e){var t=this.rotateWithView?"u_offsetScaleMatrix * u_offsetRotateMatrix":"u_offsetScaleMatrix",o=this.attributes,i=this.varyings;return e&&(o=o.concat("vec4 a_hitColor"),i=i.concat({name:"v_hitColor",type:"vec4",expression:"a_hitColor"})),"precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n"+this.uniforms.map((function(e){return"uniform "+e+";"})).join("\n")+"\nattribute vec2 a_position;\nattribute float a_index;\n"+o.map((function(e){return"attribute "+e+";"})).join("\n")+"\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n"+i.map((function(e){return"varying "+e.type+" "+e.name+";"})).join("\n")+"\nvoid main(void) {\n  mat4 offsetMatrix = "+t+";\n  vec2 halfSize = "+this.sizeExpression+" * 0.5;\n  vec2 offset = "+this.offsetExpression+";\n  float angle = "+this.rotationExpression+";\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = "+this.texCoordExpression+";\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n"+i.map((function(e){return"  "+e.name+" = "+e.expression+";"})).join("\n")+"\n}"},e.prototype.getSymbolFragmentShader=function(e){var t=e?"  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;":"",o=this.varyings;return e&&(o=o.concat({name:"v_hitColor",type:"vec4",expression:"a_hitColor"})),"precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n"+this.uniforms.map((function(e){return"uniform "+e+";"})).join("\n")+"\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n"+o.map((function(e){return"varying "+e.type+" "+e.name+";"})).join("\n")+"\nvoid main(void) {\n  if ("+this.discardExpression+") { discard; }\n  gl_FragColor = "+this.colorExpression+";\n  gl_FragColor.rgb *= gl_FragColor.a;\n"+t+"\n}"},e}();export{ShaderBuilder};export function parseLiteralStyle(e){var t=e.symbol,o=void 0!==t.size?t.size:1,i=t.color||"white",r=t.textureCoord||[0,0,1,1],s=t.offset||[0,0],n=void 0!==t.opacity?t.opacity:1,a=void 0!==t.rotation?t.rotation:0,f={inFragmentShader:!1,variables:[],attributes:[],stringLiteralsMap:{},functions:{}},l=expressionToGlsl(f,o,ValueTypes.NUMBER_ARRAY|ValueTypes.NUMBER),u=expressionToGlsl(f,s,ValueTypes.NUMBER_ARRAY),p=expressionToGlsl(f,r,ValueTypes.NUMBER_ARRAY),x=expressionToGlsl(f,a,ValueTypes.NUMBER),c={inFragmentShader:!0,variables:f.variables,attributes:[],stringLiteralsMap:f.stringLiteralsMap,functions:{}},h=expressionToGlsl(c,i,ValueTypes.COLOR),d=expressionToGlsl(c,n,ValueTypes.NUMBER),v="1.0",y="vec2("+expressionToGlsl(c,o,ValueTypes.NUMBER_ARRAY|ValueTypes.NUMBER)+").x";switch(t.symbolType){case"square":case"image":break;case"circle":v="(1.0-smoothstep(1.-4./"+y+",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))";break;case"triangle":var m="(v_quadCoord*2.-1.)",g="(atan("+m+".x,"+m+".y))";v="(1.0-smoothstep(.5-3./"+y+",.5,cos(floor(.5+"+g+"/2.094395102)*2.094395102-"+g+")*length("+m+")))";break;default:throw new Error("Unexpected symbol type: "+t.symbolType)}var E=(new ShaderBuilder).setSizeExpression("vec2("+l+")").setRotationExpression(x).setSymbolOffsetExpression(u).setTextureCoordinateExpression(p).setSymbolRotateWithView(!!t.rotateWithView).setColorExpression("vec4("+h+".rgb, "+h+".a * "+d+" * "+v+")");if(e.filter){var _=expressionToGlsl(c,e.filter,ValueTypes.BOOLEAN);E.setFragmentDiscardExpression("!"+_)}var b={};if(c.variables.forEach((function(t){var o=uniformNameForVariable(t);E.addUniform("float "+o),b[o]=function(){if(!e.variables||void 0===e.variables[t])throw new Error("The following variable is missing from the style: "+t);var o=e.variables[t];return"string"==typeof o&&(o=getStringNumberEquivalent(f,o)),void 0!==o?o:-9999999}})),"image"===t.symbolType&&t.src){var C=new Image;C.src=t.src,E.addUniform("sampler2D u_texture").setColorExpression(E.getColorExpression()+" * texture2D(u_texture, v_texCoord)"),b.u_texture=C}return c.attributes.forEach((function(e){-1===f.attributes.indexOf(e)&&f.attributes.push(e),E.addVarying("v_"+e,"float","a_"+e)})),f.attributes.forEach((function(e){E.addAttribute("float a_"+e)})),{builder:E,attributes:f.attributes.map((function(e){return{name:e,callback:function(t,o){var i=o[e];return"string"==typeof i&&(i=getStringNumberEquivalent(f,i)),void 0!==i?i:-9999999}}})),uniforms:b}}
//# sourceMappingURL=/sm/7a1b0d37dd52c46a77d7d81543d7010da883a16159fa46d86a3931c136900743.map