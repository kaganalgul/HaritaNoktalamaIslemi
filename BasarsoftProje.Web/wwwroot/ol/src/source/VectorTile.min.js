/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/source/VectorTile.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import EventType from"../events/EventType.js";import Tile from"../VectorTile.js";import TileCache from"../TileCache.js";import TileState from"../TileState.js";import UrlTile from"./UrlTile.js";import VectorRenderTile from"../VectorRenderTile.js";import{buffer as bufferExtent,getIntersection,intersects}from"../extent.js";import{createForProjection,createXYZ,extentFromProjection}from"../tilegrid.js";import{fromKey,getCacheKeyForTileKey,getKeyZXY}from"../tilecoord.js";import{isEmpty}from"../obj.js";import{loadFeaturesXhr}from"../featureloader.js";import{toSize}from"../size.js";class VectorTile extends UrlTile{constructor(e){const t=e.projection||"EPSG:3857",i=e.extent||extentFromProjection(t),o=e.tileGrid||createXYZ({extent:i,maxResolution:e.maxResolution,maxZoom:void 0!==e.maxZoom?e.maxZoom:22,minZoom:e.minZoom,tileSize:e.tileSize||512});super({attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,cacheSize:e.cacheSize,interpolate:!0,opaque:!1,projection:t,state:e.state,tileGrid:o,tileLoadFunction:e.tileLoadFunction?e.tileLoadFunction:defaultLoadFunction,tileUrlFunction:e.tileUrlFunction,url:e.url,urls:e.urls,wrapX:void 0===e.wrapX||e.wrapX,transition:e.transition,zDirection:void 0===e.zDirection?1:e.zDirection}),this.format_=e.format?e.format:null,this.sourceTileCache=new TileCache(this.tileCache.highWaterMark),this.overlaps_=null==e.overlaps||e.overlaps,this.tileClass=e.tileClass?e.tileClass:Tile,this.tileGrids_={}}getFeaturesInExtent(e){const t=[],i=this.tileCache;if(0===i.getCount())return t;const o=fromKey(i.peekFirstKey())[0],r=this.tileGrid;return i.forEach((function(i){if(i.tileCoord[0]!==o||i.getState()!==TileState.LOADED)return;const l=i.getSourceTiles();for(let i=0,o=l.length;i<o;++i){const o=l[i],s=o.tileCoord;if(intersects(e,r.getTileCoordExtent(s))){const i=o.getFeatures();if(i)for(let o=0,r=i.length;o<r;++o){const r=i[o],l=r.getGeometry();intersects(e,l.getExtent())&&t.push(r)}}}})),t}getOverlaps(){return this.overlaps_}clear(){this.tileCache.clear(),this.sourceTileCache.clear()}expireCache(e,t){const i=this.getTileCacheForProjection(e),o=Object.keys(t).reduce(((e,t)=>{const o=getCacheKeyForTileKey(t);if(i.containsKey(o)){const t=i.get(o).sourceTiles;for(let i=0,o=t.length;i<o;++i)e[t[i].getKey()]=!0}return e}),{});super.expireCache(e,t),this.sourceTileCache.expireCache(o)}getSourceTiles(e,t,i){if(i.getState()===TileState.IDLE){i.setState(TileState.LOADING);const o=i.wrappedTileCoord,r=this.getTileGridForProjection(t),l=r.getTileCoordExtent(o),s=o[0],n=r.getResolution(s);bufferExtent(l,-n,l);const a=this.tileGrid,c=a.getExtent();c&&getIntersection(l,c,l);const h=a.getZForResolution(n,1);a.forEachTileCoord(l,h,(o=>{const r=this.tileUrlFunction(o,e,t),l=this.sourceTileCache.containsKey(r)?this.sourceTileCache.get(r):new this.tileClass(o,r?TileState.IDLE:TileState.EMPTY,r,this.format_,this.tileLoadFunction);i.sourceTiles.push(l);const s=l.getState();if(s<TileState.LOADED){const e=t=>{this.handleTileChange(t);const o=l.getState();if(o===TileState.LOADED||o===TileState.ERROR){const t=l.getKey();t in i.errorTileKeys?l.getState()===TileState.LOADED&&delete i.errorTileKeys[t]:i.loadingSourceTiles--,o===TileState.ERROR?i.errorTileKeys[t]=!0:l.removeEventListener(EventType.CHANGE,e),0===i.loadingSourceTiles&&i.setState(isEmpty(i.errorTileKeys)?TileState.LOADED:TileState.ERROR)}};l.addEventListener(EventType.CHANGE,e),i.loadingSourceTiles++}s===TileState.IDLE&&(l.extent=a.getTileCoordExtent(o),l.projection=t,l.resolution=a.getResolution(o[0]),this.sourceTileCache.set(r,l),l.load())})),i.loadingSourceTiles||i.setState(i.sourceTiles.some((e=>e.getState()===TileState.ERROR))?TileState.ERROR:TileState.LOADED)}return i.sourceTiles}getTile(e,t,i,o,r){const l=getKeyZXY(e,t,i),s=this.getKey();let n;if(this.tileCache.containsKey(l)&&(n=this.tileCache.get(l),n.key===s))return n;const a=[e,t,i];let c=this.getTileCoordForTileUrlFunction(a,r);const h=this.getTileGrid().getExtent(),u=this.getTileGridForProjection(r);if(c&&h){const t=u.getTileCoordExtent(c);bufferExtent(t,-u.getResolution(e),t),intersects(h,t)||(c=null)}let T=!0;if(null!==c){const t=this.tileGrid,i=u.getResolution(e),l=t.getZForResolution(i,1),s=u.getTileCoordExtent(c);bufferExtent(s,-i,s),t.forEachTileCoord(s,l,function(e){T=T&&!this.tileUrlFunction(e,o,r)}.bind(this))}const d=new VectorRenderTile(a,T?TileState.EMPTY:TileState.IDLE,c,this.getSourceTiles.bind(this,o,r));return d.key=s,n?(d.interimTile=n,d.refreshInterimChain(),this.tileCache.replace(l,d)):this.tileCache.set(l,d),d}getTileGridForProjection(e){const t=e.getCode();let i=this.tileGrids_[t];if(!i){const o=this.tileGrid;i=createForProjection(e,void 0,o?o.getTileSize(o.getMinZoom()):void 0),this.tileGrids_[t]=i}return i}getTilePixelRatio(e){return e}getTilePixelSize(e,t,i){const o=this.getTileGridForProjection(i),r=toSize(o.getTileSize(e),this.tmpSize);return[Math.round(r[0]*t),Math.round(r[1]*t)]}updateCacheSize(e,t){super.updateCacheSize(2*e,t),this.sourceTileCache.highWaterMark=this.getTileCacheForProjection(t).highWaterMark}}export default VectorTile;export function defaultLoadFunction(e,t){e.setLoader((function(i,o,r){loadFeaturesXhr(t,e.getFormat(),i,o,r,e.onLoad.bind(e),e.onError.bind(e))}))}
//# sourceMappingURL=/sm/edfa37161924ed90a2cee0fb71375ea07d53c0e3046c5026c6d1d56817ccf28e.map