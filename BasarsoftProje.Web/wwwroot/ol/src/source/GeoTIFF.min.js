/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/source/GeoTIFF.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataTile from"./DataTile.js";import State from"./State.js";import TileGrid from"../tilegrid/TileGrid.js";import{Pool,fromUrl as tiffFromUrl,fromUrls as tiffFromUrls}from"geotiff/src/geotiff.js";import{Projection,get as getCachedProjection,toUserCoordinate,toUserExtent}from"../proj.js";import{clamp}from"../math.js";import{create as createDecoderWorker}from"../worker/geotiff-decoder.js";import{getCenter,getIntersection}from"../extent.js";import{toSize}from"../size.js";import{fromCode as unitsFromCode}from"../proj/Units.js";const STATISTICS_MAXIMUM="STATISTICS_MAXIMUM",STATISTICS_MINIMUM="STATISTICS_MINIMUM";let workerPool;function getWorkerPool(){return workerPool||(workerPool=new Pool(void 0,createDecoderWorker())),workerPool}function getBoundingBox(e){try{return e.getBoundingBox()}catch(t){const r=e.fileDirectory;return[0,0,r.ImageWidth,r.ImageLength]}}function getOrigin(e){try{return e.getOrigin().slice(0,2)}catch(t){return[0,e.fileDirectory.ImageLength]}}function getResolution(e,t){try{return e.getResolution(t)[0]}catch(r){return t.fileDirectory.ImageWidth/e.fileDirectory.ImageWidth}}function getProjection(e){const t=e.geoKeys;if(!t)return null;if(t.ProjectedCSTypeGeoKey){const e="EPSG:"+t.ProjectedCSTypeGeoKey;let r=getCachedProjection(e);if(!r){const o=unitsFromCode(t.ProjLinearUnitsGeoKey);o&&(r=new Projection({code:e,units:o}))}return r}if(t.GeographicTypeGeoKey){const e="EPSG:"+t.GeographicTypeGeoKey;let r=getCachedProjection(e);if(!r){const o=unitsFromCode(t.GeogAngularUnitsGeoKey);o&&(r=new Projection({code:e,units:o}))}return r}return null}function getImagesForTIFF(e){return e.getImageCount().then((function(t){const r=new Array(t);for(let o=0;o<t;++o)r[o]=e.getImage(o);return Promise.all(r)}))}function getImagesForSource(e){let t;return t=e.overviews?tiffFromUrls(e.url,e.overviews):tiffFromUrl(e.url),t.then(getImagesForTIFF)}function assertEqual(e,t,r,o,n){if(Array.isArray(e)){const i=e.length;if(!Array.isArray(t)||i!=t.length){const e=new Error(o);throw n(e),e}for(let s=0;s<i;++s)assertEqual(e[s],t[s],r,o,n)}else if(t=t,Math.abs(e-t)>r*e)throw new Error(o)}function getMinForDataType(e){return e instanceof Int8Array?-128:e instanceof Int16Array?-32768:e instanceof Int32Array?-2147483648:e instanceof Float32Array?12e-39:0}function getMaxForDataType(e){return e instanceof Int8Array?127:e instanceof Uint8Array||e instanceof Uint8ClampedArray?255:e instanceof Int16Array?32767:e instanceof Uint16Array?65535:e instanceof Int32Array?2147483647:e instanceof Uint32Array?4294967295:e instanceof Float32Array?34e37:255}class GeoTIFFSource extends DataTile{constructor(e){super({state:State.LOADING,tileGrid:null,projection:null,opaque:e.opaque,transition:e.transition,interpolate:!1!==e.interpolate,wrapX:e.wrapX}),this.sourceInfo_=e.sources;const t=this.sourceInfo_.length;this.sourceImagery_=new Array(t),this.resolutionFactors_=new Array(t),this.samplesPerPixel_,this.nodataValues_,this.metadata_,this.normalize_=!1!==e.normalize,this.addAlpha_=!1,this.error_=null,this.readMethod_=e.convertToRGB?"readRGB":"readRasters",this.setKey(this.sourceInfo_.map((e=>e.url)).join(","));const r=this,o=new Array(t);for(let e=0;e<t;++e)o[e]=getImagesForSource(this.sourceInfo_[e]);Promise.all(o).then((function(e){r.configure_(e)})).catch((function(e){console.error(e),r.error_=e,r.setState(State.ERROR)}))}getError(){return this.error_}configure_(e){let t,r,o,n;const i=new Array(e.length),s=new Array(e.length),a=new Array(e.length);let l=0;const c=e.length;for(let h=0;h<c;++h){const c=e[h],u=c.length;let f,g;const d=new Array(u),m=new Array(u);s[h]=new Array(u),a[h]=new Array(u);for(let e=0;e<u;++e){const t=c[e],r=t.getGDALNoData();a[h][e]=t.getGDALMetadata(),s[h][e]=null===r?NaN:r;const o=this.sourceInfo_[h].bands;i[h]=o?o.length:t.getSamplesPerPixel();const n=u-(e+1);f||(f=getBoundingBox(t)),g||(g=getOrigin(t)),m[n]=getResolution(t,c[0]),d[n]=[t.getTileWidth(),t.getTileHeight()]}if(t?getIntersection(t,f,t):t=f,r){assertEqual(r,g,0,`Origin mismatch for source ${h}, got [${g}] but expected [${r}]`,this.viewRejector)}else r=g;if(n){n.length-l>m.length&&(l=n.length-m.length);const e=n[n.length-1]/m[m.length-1];this.resolutionFactors_[h]=e;const t=m.map((t=>t*e)),r=`Resolution mismatch for source ${h}, got [${t}] but expected [${n}]`;assertEqual(n.slice(l,n.length),t,.005,r,this.viewRejector)}else n=m,this.resolutionFactors_[h]=1;o?assertEqual(o.slice(l,o.length),d,0,`Tile size mismatch for source ${h}`,this.viewRejector):o=d,this.sourceImagery_[h]=c.reverse()}for(let e=0,t=this.sourceImagery_.length;e<t;++e){const t=this.sourceImagery_[e];for(;t.length<n.length;)t.unshift(void 0)}if(!this.getProjection()){const t=e[0];for(let e=t.length-1;e>=0;--e){const r=getProjection(t[e]);if(r){this.projection=r;break}}}this.samplesPerPixel_=i,this.nodataValues_=s,this.metadata_=a;e:for(let e=0;e<c;++e){if(void 0!==this.sourceInfo_[e].nodata){this.addAlpha_=!0;break}const t=s[e],r=this.sourceInfo_[e].bands;if(r){for(let e=0;e<r.length;++e)if(!isNaN(t[r[e]-1])){this.addAlpha_=!0;break e}}else for(let e=0;e<t.length;++e)if(!isNaN(t[e])){this.addAlpha_=!0;break e}}const h=this.addAlpha_?1:0;this.bandCount=i.reduce(((e,t)=>e+=t),0)+h;const u=new TileGrid({extent:t,minZoom:l,origin:r,resolutions:n,tileSizes:o});this.tileGrid=u,this.setLoader(this.loadTile_.bind(this)),this.setState(State.READY),this.viewResolver({projection:this.projection,resolutions:n,center:toUserCoordinate(getCenter(t),this.projection),extent:toUserExtent(t,this.projection),zoom:0})}loadTile_(e,t,r){const o=toSize(this.tileGrid.getTileSize(e)),n=this.sourceImagery_.length,i=new Array(n),s=this.addAlpha_,a=this.bandCount,l=this.samplesPerPixel_,c=this.nodataValues_,h=this.sourceInfo_;for(let s=0;s<n;++s){const n=h[s],a=this.resolutionFactors_[s],l=[Math.round(t*(o[0]*a)),Math.round(r*(o[1]*a)),Math.round((t+1)*(o[0]*a)),Math.round((r+1)*(o[1]*a))],u=this.sourceImagery_[s][e];let f,g;n.bands&&(f=n.bands.map((function(e){return e-1}))),g=isNaN(n.nodata)?f?f.map((function(e){return c[s][e]})):c[s]:n.nodata,i[s]=u[this.readMethod_]({window:l,width:o[0],height:o[1],samples:f,fillValue:g,pool:getWorkerPool(),interleave:!1})}const u=o[0]*o[1],f=u*a,g=this.normalize_,d=this.metadata_;return Promise.all(i).then((function(e){let t;t=g?new Uint8Array(f):new Float32Array(f);let r=0;for(let o=0;o<u;++o){let i=s;for(let a=0;a<n;++a){const n=h[a];let u,f,m=n.min,I=n.max;if(g){const t=d[a][0];void 0===m&&(m=t&&STATISTICS_MINIMUM in t?parseFloat(t.STATISTICS_MINIMUM):getMinForDataType(e[a][0])),void 0===I&&(I=t&&STATISTICS_MAXIMUM in t?parseFloat(t.STATISTICS_MAXIMUM):getMaxForDataType(e[a][0])),u=255/(I-m),f=-m*u}for(let h=0;h<l[a];++h){const l=e[a][h][o];let d;if(d=g?clamp(u*l+f,0,255):l,s){let e=n.nodata;if(void 0===e){let t;t=n.bands?n.bands[h]-1:h,e=c[a][t]}l!==e&&(i=!1,t[r]=d)}else t[r]=d;r++}}s&&(i||(t[r]=255),r++)}return t}))}}GeoTIFFSource.prototype.getView;export default GeoTIFFSource;
//# sourceMappingURL=/sm/bbcda9fb096ed11ac7721118e7335f8fcda2d7d5c2ee22f5b8118e315964babe.map