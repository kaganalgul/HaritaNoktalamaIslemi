/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/interaction/Snap.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CollectionEventType from"../CollectionEventType.js";import EventType from"../events/EventType.js";import GeometryType from"../geom/GeometryType.js";import PointerInteraction from"./Pointer.js";import RBush from"../structs/RBush.js";import VectorEventType from"../source/VectorEventType.js";import{FALSE,TRUE}from"../functions.js";import{boundingExtent,createEmpty}from"../extent.js";import{closestOnCircle,closestOnSegment,distance as coordinateDistance,squaredDistance as squaredCoordinateDistance,squaredDistanceToSegment}from"../coordinate.js";import{fromCircle}from"../geom/Polygon.js";import{fromUserCoordinate,getUserProjection,toUserCoordinate}from"../proj.js";import{getUid}from"../util.js";import{getValues}from"../obj.js";import{listen,unlistenByKey}from"../events.js";function getFeatureFromEvent(e){return e.feature?e.feature:e.element?e.element:void 0}const tempSegment=[];class Snap extends PointerInteraction{constructor(e){const t=e||{},r=t;r.handleDownEvent||(r.handleDownEvent=TRUE),r.stopDown||(r.stopDown=FALSE),super(r),this.source_=t.source?t.source:null,this.vertex_=void 0===t.vertex||t.vertex,this.edge_=void 0===t.edge||t.edge,this.features_=t.features?t.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=void 0!==t.pixelTolerance?t.pixelTolerance:10,this.rBush_=new RBush,this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this)}}addFeature(e,t){const r=void 0===t||t,n=getUid(e),o=e.getGeometry();if(o){const t=this.SEGMENT_WRITERS_[o.getType()];t&&(this.indexedFeaturesExtents_[n]=o.getExtent(createEmpty()),t(e,o))}r&&(this.featureChangeListenerKeys_[n]=listen(e,EventType.CHANGE,this.handleFeatureChange_,this))}forEachFeatureAdd_(e){this.addFeature(e)}forEachFeatureRemove_(e){this.removeFeature(e)}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t.snapped&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel),super.handleEvent(e)}handleFeatureAdd_(e){const t=getFeatureFromEvent(e);this.addFeature(t)}handleFeatureRemove_(e){const t=getFeatureFromEvent(e);this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const e=getUid(t);e in this.pendingFeatures_||(this.pendingFeatures_[e]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=getValues(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const r=void 0===t||t,n=getUid(e),o=this.indexedFeaturesExtents_[n];if(o){const t=this.rBush_,r=[];t.forEachInExtent(o,(function(t){e===t.feature&&r.push(t)}));for(let e=r.length-1;e>=0;--e)t.remove(r[e])}r&&(unlistenByKey(this.featureChangeListenerKeys_[n]),delete this.featureChangeListenerKeys_[n])}setMap(e){const t=this.getMap(),r=this.featuresListenerKeys_,n=this.getFeatures_();t&&(r.forEach(unlistenByKey),r.length=0,n.forEach(this.forEachFeatureRemove_.bind(this))),super.setMap(e),e&&(this.features_?r.push(listen(this.features_,CollectionEventType.ADD,this.handleFeatureAdd_,this),listen(this.features_,CollectionEventType.REMOVE,this.handleFeatureRemove_,this)):this.source_&&r.push(listen(this.source_,VectorEventType.ADDFEATURE,this.handleFeatureAdd_,this),listen(this.source_,VectorEventType.REMOVEFEATURE,this.handleFeatureRemove_,this)),n.forEach(this.forEachFeatureAdd_.bind(this)))}snapTo(e,t,r){const n=r.getCoordinateFromPixel([e[0]-this.pixelTolerance_,e[1]+this.pixelTolerance_]),o=r.getCoordinateFromPixel([e[0]+this.pixelTolerance_,e[1]-this.pixelTolerance_]),i=boundingExtent([n,o]);let s=this.rBush_.getInExtent(i);this.vertex_&&!this.edge_&&(s=s.filter((function(e){return e.feature.getGeometry().getType()!==GeometryType.CIRCLE})));let a=!1,h=null,l=null;if(0===s.length)return{snapped:a,vertex:h,vertexPixel:l};const u=r.getView().getProjection(),c=fromUserCoordinate(t,u);let d,g=1/0;for(let e=0;e<s.length;++e){const t=s[e];tempSegment[0]=fromUserCoordinate(t.segment[0],u),tempSegment[1]=fromUserCoordinate(t.segment[1],u);const r=squaredDistanceToSegment(c,tempSegment);r<g&&(d=t,g=r)}const m=d.segment;if(this.vertex_&&!this.edge_){const t=r.getPixelFromCoordinate(m[0]),n=r.getPixelFromCoordinate(m[1]),o=squaredCoordinateDistance(e,t),i=squaredCoordinateDistance(e,n);Math.sqrt(Math.min(o,i))<=this.pixelTolerance_&&(a=!0,h=o>i?m[1]:m[0],l=r.getPixelFromCoordinate(h))}else if(this.edge_){const t=d.feature.getGeometry().getType()===GeometryType.CIRCLE;if(t){let e=d.feature.getGeometry();const t=getUserProjection();t&&(e=e.clone().transform(t,u)),h=toUserCoordinate(closestOnCircle(c,e),u)}else tempSegment[0]=fromUserCoordinate(m[0],u),tempSegment[1]=fromUserCoordinate(m[1],u),h=toUserCoordinate(closestOnSegment(c,tempSegment),u);if(l=r.getPixelFromCoordinate(h),coordinateDistance(e,l)<=this.pixelTolerance_&&(a=!0,this.vertex_&&!t)){const e=r.getPixelFromCoordinate(m[0]),t=r.getPixelFromCoordinate(m[1]),n=squaredCoordinateDistance(l,e),o=squaredCoordinateDistance(l,t);Math.sqrt(Math.min(n,o))<=this.pixelTolerance_&&(h=n>o?m[1]:m[0],l=r.getPixelFromCoordinate(h))}}return a&&(l=[Math.round(l[0]),Math.round(l[1])]),{snapped:a,vertex:h,vertexPixel:l}}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}writeCircleGeometry_(e,t){const r=this.getMap().getView().getProjection();let n=t;const o=getUserProjection();o&&(n=n.clone().transform(o,r));const i=fromCircle(n);o&&i.transform(r,o);const s=i.getCoordinates()[0];for(let t=0,r=s.length-1;t<r;++t){const r=s.slice(t,t+2),n={feature:e,segment:r};this.rBush_.insert(boundingExtent(r),n)}}writeGeometryCollectionGeometry_(e,t){const r=t.getGeometriesArray();for(let t=0;t<r.length;++t){const n=this.SEGMENT_WRITERS_[r[t].getType()];n&&n(e,r[t])}}writeLineStringGeometry_(e,t){const r=t.getCoordinates();for(let t=0,n=r.length-1;t<n;++t){const n=r.slice(t,t+2),o={feature:e,segment:n};this.rBush_.insert(boundingExtent(n),o)}}writeMultiLineStringGeometry_(e,t){const r=t.getCoordinates();for(let t=0,n=r.length;t<n;++t){const n=r[t];for(let t=0,r=n.length-1;t<r;++t){const r=n.slice(t,t+2),o={feature:e,segment:r};this.rBush_.insert(boundingExtent(r),o)}}}writeMultiPointGeometry_(e,t){const r=t.getCoordinates();for(let n=0,o=r.length;n<o;++n){const o=r[n],i={feature:e,segment:[o,o]};this.rBush_.insert(t.getExtent(),i)}}writeMultiPolygonGeometry_(e,t){const r=t.getCoordinates();for(let t=0,n=r.length;t<n;++t){const n=r[t];for(let t=0,r=n.length;t<r;++t){const r=n[t];for(let t=0,n=r.length-1;t<n;++t){const n=r.slice(t,t+2),o={feature:e,segment:n};this.rBush_.insert(boundingExtent(n),o)}}}}writePointGeometry_(e,t){const r=t.getCoordinates(),n={feature:e,segment:[r,r]};this.rBush_.insert(t.getExtent(),n)}writePolygonGeometry_(e,t){const r=t.getCoordinates();for(let t=0,n=r.length;t<n;++t){const n=r[t];for(let t=0,r=n.length-1;t<r;++t){const r=n.slice(t,t+2),o={feature:e,segment:r};this.rBush_.insert(boundingExtent(r),o)}}}}export default Snap;
//# sourceMappingURL=/sm/62f0d7d78073aedf1c1e6c9eb3185b0ae51dcc1151e86cf53c0248dd37c32cf9.map