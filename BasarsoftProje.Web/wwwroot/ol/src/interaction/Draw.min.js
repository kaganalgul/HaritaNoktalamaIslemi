/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/interaction/Draw.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Circle from"../geom/Circle.js";import Event from"../events/Event.js";import EventType from"../events/EventType.js";import Feature from"../Feature.js";import GeometryType from"../geom/GeometryType.js";import InteractionProperty from"./Property.js";import LineString from"../geom/LineString.js";import MapBrowserEvent from"../MapBrowserEvent.js";import MapBrowserEventType from"../MapBrowserEventType.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import PointerInteraction from"./Pointer.js";import Polygon,{fromCircle,makeRegular}from"../geom/Polygon.js";import VectorLayer from"../layer/Vector.js";import VectorSource from"../source/Vector.js";import{FALSE,TRUE}from"../functions.js";import{always,noModifierKeys,shiftKeyOnly}from"../events/condition.js";import{boundingExtent,getBottomLeft,getBottomRight,getTopLeft,getTopRight}from"../extent.js";import{createEditingStyle}from"../style/Style.js";import{fromUserCoordinate,getUserProjection}from"../proj.js";import{squaredDistance as squaredCoordinateDistance}from"../coordinate.js";const Mode={POINT:"Point",LINE_STRING:"LineString",POLYGON:"Polygon",CIRCLE:"Circle"},DrawEventType={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};export class DrawEvent extends Event{constructor(e,t){super(e),this.feature=t}}class Draw extends PointerInteraction{constructor(e){const t=e;t.stopDown||(t.stopDown=FALSE),super(t),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=getMode(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_===Mode.POLYGON?3:2,this.maxPoints_=this.mode_===Mode.CIRCLE?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:TRUE;let i=e.geometryFunction;if(!i){const e=this.mode_;if(e===Mode.CIRCLE)i=function(e,t,i){const o=t||new Circle([NaN,NaN]),s=fromUserCoordinate(e[0],i),n=squaredCoordinateDistance(s,fromUserCoordinate(e[e.length-1],i));o.setCenterAndRadius(s,Math.sqrt(n));const r=getUserProjection();return r&&o.transform(i,r),o};else{let t;e===Mode.POINT?t=Point:e===Mode.LINE_STRING?t=LineString:e===Mode.POLYGON&&(t=Polygon),i=function(i,o,s){return o?e===Mode.POLYGON?i[0].length?o.setCoordinates([i[0].concat([i[0][0]])]):o.setCoordinates([]):o.setCoordinates(i):o=new t(i),o}}}this.geometryFunction_=i,this.dragVertexDelay_=void 0!==e.dragVertexDelay?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new VectorLayer({source:new VectorSource({useSpatialIndex:!1,wrapX:!!e.wrapX&&e.wrapX}),style:e.style?e.style:getDefaultStyleFunction(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:noModifierKeys,this.freehandCondition_,e.freehand?this.freehandCondition_=always:this.freehandCondition_=e.freehandCondition?e.freehandCondition:shiftKeyOnly,this.addChangeListener(InteractionProperty.ACTIVE,this.updateState_)}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===EventType.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!==Mode.POINT&&this.freehandCondition_(e);let t=e.type===MapBrowserEventType.POINTERMOVE,i=!0;if(!this.freehand_&&this.lastDragTime_&&e.type===MapBrowserEventType.POINTERDRAG){Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)}return this.freehand_&&e.type===MapBrowserEventType.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(e.coordinate),i=!1):this.freehand_&&e.type===MapBrowserEventType.POINTERDOWN?i=!1:t&&this.getPointerCount()<2?(i=e.type===MapBrowserEventType.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):("mouse"===e.originalEvent.pointerType||e.type===MapBrowserEventType.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(e)):e.type===MapBrowserEventType.DBLCLICK&&(i=!1),super.handleEvent(e)&&i}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(function(){this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))}.bind(this),this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}handleUpEvent(e){let t=!0;if(0===this.getPointerCount())if(this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(e.coordinate),!i&&this.freehand_?this.finishDrawing():this.freehand_||i&&this.mode_!==Mode.POINT||(this.atFinish_(e.pixel)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing();return!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,i=e.pixel,o=t[0]-i[0],s=t[1]-i[1],n=o*o+s*s;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?this.modifyDrawing_(e.coordinate):this.createOrUpdateSketchPoint_(e.coordinate.slice())}atFinish_(e){let t=!1;if(this.sketchFeature_){let i=!1,o=[this.finishCoordinate_];const s=this.mode_;if(s===Mode.POINT)t=!0;else if(s===Mode.CIRCLE)t=2===this.sketchCoords_.length;else if(s===Mode.LINE_STRING)i=this.sketchCoords_.length>this.minPoints_;else if(s===Mode.POLYGON){const e=this.sketchCoords_;i=e[0].length>this.minPoints_,o=[e[0][0],e[0][e[0].length-2]]}if(i){const i=this.getMap();for(let s=0,n=o.length;s<n;s++){const n=o[s],r=i.getPixelFromCoordinate(n),h=e[0]-r[0],a=e[1]-r[1],d=this.freehand_?1:this.snapTolerance_;if(t=Math.sqrt(h*h+a*a)<=d,t){this.finishCoordinate_=n;break}}}}return t}createOrUpdateSketchPoint_(e){if(this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(e)}else this.sketchPoint_=new Feature(new Point(e)),this.updateSketchFeatures_()}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new Feature);const t=e.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),i.changed()):(i=new LineString(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(e){const t=this.getMap().getView().getProjection();this.finishCoordinate_=e,this.mode_===Mode.POINT?this.sketchCoords_=e.slice():this.mode_===Mode.POLYGON?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new Feature(new LineString(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new Feature,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),i=this.sketchFeature_.getGeometry(),o=t.getView().getProjection();let s,n;if(this.mode_===Mode.POINT?n=this.sketchCoords_:this.mode_===Mode.POLYGON?(s=this.sketchCoords_[0],n=s[s.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(s=this.sketchCoords_,n=s[s.length-1]),n[0]=e[0],n[1]=e[1],this.geometryFunction_(this.sketchCoords_,i,o),this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(e)}if(i.getType()===GeometryType.POLYGON&&this.mode_!==Mode.POLYGON)this.createOrUpdateCustomSketchLine_(i);else if(this.sketchLineCoords_){this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)}this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let o,s;const n=this.mode_;n===Mode.LINE_STRING||n===Mode.CIRCLE?(this.finishCoordinate_=e.slice(),s=this.sketchCoords_,s.length>=this.maxPoints_&&(this.freehand_?s.pop():o=!0),s.push(e.slice()),this.geometryFunction_(s,t,i)):n===Mode.POLYGON&&(s=this.sketchCoords_[0],s.length>=this.maxPoints_&&(this.freehand_?s.pop():o=!0),s.push(e.slice()),o&&(this.finishCoordinate_=s[0]),this.geometryFunction_(this.sketchCoords_,t,i)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),o&&this.finishDrawing()}removeLastPoint(){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),t=this.getMap().getView().getProjection();let i;const o=this.mode_;if(o===Mode.LINE_STRING||o===Mode.CIRCLE){if(i=this.sketchCoords_,i.splice(-2,1),i.length>=2){this.finishCoordinate_=i[i.length-2].slice();const e=this.finishCoordinate_.slice();i[i.length-1]=e,this.createOrUpdateSketchPoint_(e)}this.geometryFunction_(i,e,t),e.getType()===GeometryType.POLYGON&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(o===Mode.POLYGON){i=this.sketchCoords_[0],i.splice(-2,1);const o=this.sketchLine_.getGeometry();if(i.length>=2){const e=i[i.length-2].slice();i[i.length-1]=e,this.createOrUpdateSketchPoint_(e)}o.setCoordinates(i),this.geometryFunction_(this.sketchCoords_,e,t)}1===i.length&&this.abortDrawing(),this.updateSketchFeatures_()}finishDrawing(){const e=this.abortDrawing_();if(!e)return;let t=this.sketchCoords_;const i=e.getGeometry(),o=this.getMap().getView().getProjection();this.mode_===Mode.LINE_STRING?(t.pop(),this.geometryFunction_(t,i,o)):this.mode_===Mode.POLYGON&&(t[0].pop(),this.geometryFunction_(t,i,o),t=i.getCoordinates()),this.type_===GeometryType.MULTI_POINT?e.setGeometry(new MultiPoint([t])):this.type_===GeometryType.MULTI_LINE_STRING?e.setGeometry(new MultiLineString([t])):this.type_===GeometryType.MULTI_POLYGON&&e.setGeometry(new MultiPolygon([t])),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e)}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,i=!this.sketchFeature_;let o;if(i&&this.startDrawing_(e[0]),t===Mode.LINE_STRING||t===Mode.CIRCLE)o=this.sketchCoords_;else{if(t!==Mode.POLYGON)return;o=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}i&&o.shift(),o.pop();for(let t=0;t<e.length;t++)this.addToDrawing_(e[t]);const s=e[e.length-1];this.addToDrawing_(s),this.modifyDrawing_(s)}extend(e){const t=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=t.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new Feature(new Point(i)),this.updateSketchFeatures_(),this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();e&&t||this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function getDefaultStyleFunction(){const e=createEditingStyle();return function(t,i){return e[t.getGeometry().getType()]}}export function createRegularPolygon(e,t){return function(i,o,s){const n=fromUserCoordinate(i[0],s),r=fromUserCoordinate(i[i.length-1],s),h=Math.sqrt(squaredCoordinateDistance(n,r)),a=o||fromCircle(new Circle(n),e);let d=t;if(!t&&0!==t){const e=r[0]-n[0],t=r[1]-n[1];d=Math.atan2(t,e)}makeRegular(a,n,h,d);const c=getUserProjection();return c&&a.transform(s,c),a}}export function createBox(){return function(e,t,i){const o=boundingExtent([e[0],e[e.length-1]].map((function(e){return fromUserCoordinate(e,i)}))),s=[[getBottomLeft(o),getBottomRight(o),getTopRight(o),getTopLeft(o),getBottomLeft(o)]];let n=t;n?n.setCoordinates(s):n=new Polygon(s);const r=getUserProjection();return r&&n.transform(i,r),n}}function getMode(e){switch(e){case GeometryType.POINT:case GeometryType.MULTI_POINT:return Mode.POINT;case GeometryType.LINE_STRING:case GeometryType.MULTI_LINE_STRING:return Mode.LINE_STRING;case GeometryType.POLYGON:case GeometryType.MULTI_POLYGON:return Mode.POLYGON;case GeometryType.CIRCLE:return Mode.CIRCLE;default:throw new Error("Invalid type: "+e)}}export default Draw;
//# sourceMappingURL=/sm/992389cb7b844d1ba1b20fe8dcf9452c12ffe7babd099e8ddfe7eae6bb104a60.map