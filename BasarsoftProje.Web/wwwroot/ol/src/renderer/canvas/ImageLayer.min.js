/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/renderer/canvas/ImageLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasLayerRenderer from"./Layer.js";import ViewHint from"../../ViewHint.js";import{ENABLE_RASTER_REPROJECTION}from"../../reproj/common.js";import{IMAGE_SMOOTHING_DISABLED,IMAGE_SMOOTHING_ENABLED}from"./common.js";import{assign}from"../../obj.js";import{compose as composeTransform,makeInverse}from"../../transform.js";import{containsExtent,intersects as intersectsExtent}from"../../extent.js";import{fromUserExtent}from"../../proj.js";import{getIntersection,isEmpty}from"../../extent.js";import{toString as toTransformString}from"../../transform.js";class CanvasImageLayerRenderer extends CanvasLayerRenderer{constructor(t){super(t),this.image_=null}getImage(){return this.image_?this.image_.getImage():null}prepareFrame(t){const e=t.layerStatesArray[t.layerIndex],r=t.pixelRatio,n=t.viewState,o=n.resolution,s=this.getLayer().getSource(),i=t.viewHints;let a=t.extent;if(void 0!==e.extent&&(a=getIntersection(a,fromUserExtent(e.extent,n.projection))),!i[ViewHint.ANIMATING]&&!i[ViewHint.INTERACTING]&&!isEmpty(a))if(s){let t=n.projection;if(!ENABLE_RASTER_REPROJECTION){const e=s.getProjection();e&&(t=e)}const e=s.getImage(a,o,r,t);e&&this.loadImage(e)&&(this.image_=e)}else this.image_=null;return!!this.image_}renderFrame(t,e){const r=this.image_,n=r.getExtent(),o=r.getResolution(),s=r.getPixelRatio(),i=t.layerStatesArray[t.layerIndex],a=t.pixelRatio,m=t.viewState,h=m.center,c=m.resolution,g=t.size,l=a*o/(c*s);let p=Math.round(g[0]*a),f=Math.round(g[1]*a);const E=m.rotation;if(E){const t=Math.round(Math.sqrt(p*p+f*f));p=t,f=t}composeTransform(this.pixelTransform,t.size[0]/2,t.size[1]/2,1/a,1/a,E,-p/2,-f/2),makeInverse(this.inversePixelTransform,this.pixelTransform);const I=toTransformString(this.pixelTransform);this.useContainer(e,I,i.opacity,this.getBackground(t));const d=this.context,x=d.canvas;x.width!=p||x.height!=f?(x.width=p,x.height=f):this.containerReused||d.clearRect(0,0,p,f);let u=!1,R=!0;if(i.extent){const e=fromUserExtent(i.extent,m.projection);R=intersectsExtent(e,t.extent),u=R&&!containsExtent(e,t.extent),u&&this.clipUnrotated(d,t,e)}const T=r.getImage(),A=composeTransform(this.tempTransform,p/2,f/2,l,l,0,s*(n[0]-h[0])/o,s*(h[1]-n[3])/o);this.renderedResolution=o*a/s;const y=T.width*A[0],_=T.height*A[3];if(this.getLayer().getSource().getInterpolate()||assign(d,IMAGE_SMOOTHING_DISABLED),this.preRender(d,t),R&&y>=.5&&_>=.5){const t=A[4],e=A[5],r=i.opacity;let n;1!==r&&(n=d.globalAlpha,d.globalAlpha=r),d.drawImage(T,0,0,+T.width,+T.height,Math.round(t),Math.round(e),Math.round(y),Math.round(_)),1!==r&&(d.globalAlpha=n)}return this.postRender(d,t),u&&d.restore(),assign(d,IMAGE_SMOOTHING_ENABLED),I!==x.style.transform&&(x.style.transform=I),this.container}}export default CanvasImageLayerRenderer;
//# sourceMappingURL=/sm/e20ecd6b00cd21e8221ba83f300f5780d68c0e57506651c397c87dd92e5ae81a.map