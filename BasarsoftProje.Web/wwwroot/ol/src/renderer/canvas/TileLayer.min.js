/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/renderer/canvas/TileLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasLayerRenderer from"./Layer.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import{IMAGE_SMOOTHING_DISABLED,IMAGE_SMOOTHING_ENABLED}from"./common.js";import{apply as applyTransform,compose as composeTransform,makeInverse}from"../../transform.js";import{assign}from"../../obj.js";import{createEmpty,equals,getIntersection,getTopLeft}from"../../extent.js";import{cssOpacity}from"../../css.js";import{fromUserExtent}from"../../proj.js";import{getUid}from"../../util.js";import{numberSafeCompareFunction}from"../../array.js";import{toString as toTransformString}from"../../transform.js";class CanvasTileLayerRenderer extends CanvasLayerRenderer{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=createEmpty(),this.tmpTileRange_=new TileRange(0,0,0,0)}isDrawableTile(e){const t=this.getLayer(),i=e.getState(),r=t.getUseInterimTilesOnError();return i==TileState.LOADED||i==TileState.EMPTY||i==TileState.ERROR&&!r}getTile(e,t,i,r){const n=r.pixelRatio,s=r.viewState.projection,o=this.getLayer();let a=o.getSource().getTile(e,t,i,n,s);return a.getState()==TileState.ERROR&&(o.getUseInterimTilesOnError()?o.getPreload()>0&&(this.newTiles_=!0):a.setState(TileState.LOADED)),this.isDrawableTile(a)||(a=a.getInterimTile()),a}loadedTileCallback(e,t,i){return!!this.isDrawableTile(i)&&super.loadedTileCallback(e,t,i)}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(e,t){const i=e.layerStatesArray[e.layerIndex],r=e.viewState,n=r.projection,s=r.resolution,o=r.center,a=r.rotation,l=e.pixelRatio,d=this.getLayer(),h=d.getSource(),c=h.getRevision(),g=h.getTileGridForProjection(n),T=g.getZForResolution(s,h.zDirection),m=g.getResolution(T);let p=e.extent;const u=i.extent&&fromUserExtent(i.extent,n);u&&(p=getIntersection(p,fromUserExtent(i.extent,n)));const f=h.getTilePixelRatio(l);let x=Math.round(e.size[0]*f),R=Math.round(e.size[1]*f);if(a){const e=Math.round(Math.sqrt(x*x+R*R));x=e,R=e}const y=m*x/2/f,E=m*R/2/f,S=[o[0]-y,o[1]-E,o[0]+y,o[1]+E],C=g.getTileRangeForExtentAndZ(p,T),I={};I[T]={};const j=this.createLoadedTileFinder(h,n,I),v=this.tmpExtent,w=this.tmpTileRange_;this.newTiles_=!1;for(let t=C.minX;t<=C.maxX;++t)for(let i=C.minY;i<=C.maxY;++i){const r=this.getTile(T,t,i,e);if(this.isDrawableTile(r)){const t=getUid(this);if(r.getState()==TileState.LOADED){I[T][r.tileCoord.toString()]=r;const e=r.inTransition(t);this.newTiles_||!e&&-1!==this.renderedTiles.indexOf(r)||(this.newTiles_=!0)}if(1===r.getAlpha(t,e.time))continue}const n=g.getTileCoordChildTileRange(r.tileCoord,w,v);let s=!1;n&&(s=j(T+1,n)),s||g.forEachTileCoordParentTileRange(r.tileCoord,j,w,v)}const L=m/s;composeTransform(this.pixelTransform,e.size[0]/2,e.size[1]/2,1/f,1/f,a,-x/2,-R/2);const A=toTransformString(this.pixelTransform);this.useContainer(t,A,i.opacity,this.getBackground(e));const O=this.context,_=O.canvas;makeInverse(this.inversePixelTransform,this.pixelTransform),composeTransform(this.tempTransform,x/2,R/2,L,L,0,-x/2,-R/2),_.width!=x||_.height!=R?(_.width=x,_.height=R):this.containerReused||O.clearRect(0,0,x,R),u&&this.clipUnrotated(O,e,u),h.getInterpolate()||assign(O,IMAGE_SMOOTHING_DISABLED),this.preRender(O,e),this.renderedTiles.length=0;let D,M,P,b=Object.keys(I).map(Number);b.sort(numberSafeCompareFunction),1!==i.opacity||this.containerReused&&!h.getOpaque(e.viewState.projection)?(D=[],M=[]):b=b.reverse();for(let t=b.length-1;t>=0;--t){const i=b[t],r=h.getTilePixelSize(i,l,n),s=g.getResolution(i)/m,o=r[0]*s*L,a=r[1]*s*L,d=g.getTileCoordForCoordAndZ(getTopLeft(S),i),c=g.getTileCoordExtent(d),p=applyTransform(this.tempTransform,[f*(c[0]-S[0])/m,f*(S[3]-c[3])/m]),u=f*h.getGutterForProjection(n),x=I[i];for(const t in x){const r=x[t],n=r.tileCoord,s=d[1]-n[1],l=Math.round(p[0]-(s-1)*o),c=d[2]-n[2],g=Math.round(p[1]-(c-1)*a),m=Math.round(p[0]-s*o),f=Math.round(p[1]-c*a),R=l-m,y=g-f,E=T===i,S=E&&1!==r.getAlpha(getUid(this),e.time);if(!S)if(D){O.save(),P=[m,f,m+R,f,m+R,f+y,m,f+y];for(let e=0,t=D.length;e<t;++e)if(T!==i&&i<M[e]){const t=D[e];O.beginPath(),O.moveTo(P[0],P[1]),O.lineTo(P[2],P[3]),O.lineTo(P[4],P[5]),O.lineTo(P[6],P[7]),O.moveTo(t[6],t[7]),O.lineTo(t[4],t[5]),O.lineTo(t[2],t[3]),O.lineTo(t[0],t[1]),O.clip()}D.push(P),M.push(i)}else O.clearRect(m,f,R,y);this.drawTileImage(r,e,m,f,R,y,u,E),D&&!S?(O.restore(),this.renderedTiles.unshift(r)):this.renderedTiles.push(r),this.updateUsedTiles(e.usedTiles,h,r)}}this.renderedRevision=c,this.renderedResolution=m,this.extentChanged=!this.renderedExtent_||!equals(this.renderedExtent_,S),this.renderedExtent_=S,this.renderedPixelRatio=l,this.renderedProjection=n,this.manageTilePyramid(e,h,g,l,n,p,T,d.getPreload()),this.scheduleExpireCache(e,h),this.postRender(O,e),i.extent&&O.restore(),assign(O,IMAGE_SMOOTHING_ENABLED),A!==_.style.transform&&(_.style.transform=A);const U=cssOpacity(i.opacity),F=this.container;return U!==F.style.opacity&&(F.style.opacity=U),this.container}drawTileImage(e,t,i,r,n,s,o,a){const l=this.getTileImage(e);if(!l)return;const d=getUid(this),h=a?e.getAlpha(d,t.time):1,c=h!==this.context.globalAlpha;c&&(this.context.save(),this.context.globalAlpha=h),this.context.drawImage(l,o,o,l.width-2*o,l.height-2*o,i,r,n,s),c&&this.context.restore(),1!==h?t.animate=!0:a&&e.endTransition(d)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){if(t.canExpireCache()){const i=function(e,t,i){const r=getUid(e);r in i.usedTiles&&e.expireCache(i.viewState.projection,i.usedTiles[r])}.bind(null,t);e.postRenderFunctions.push(i)}}updateUsedTiles(e,t,i){const r=getUid(t);r in e||(e[r]={}),e[r][i.getKey()]=!0}manageTilePyramid(e,t,i,r,n,s,o,a,l){const d=getUid(t);d in e.wantedTiles||(e.wantedTiles[d]={});const h=e.wantedTiles[d],c=e.tileQueue;let g,T,m,p,u,f,x=0;for(f=i.getMinZoom();f<=o;++f)for(T=i.getTileRangeForExtentAndZ(s,f,T),m=i.getResolution(f),p=T.minX;p<=T.maxX;++p)for(u=T.minY;u<=T.maxY;++u)o-f<=a?(++x,g=t.getTile(f,p,u,r,n),g.getState()==TileState.IDLE&&(h[g.getKey()]=!0,c.isKeyQueued(g.getKey())||c.enqueue([g,d,i.getTileCoordCenter(g.tileCoord),m])),void 0!==l&&l(g)):t.useTile(f,p,u,n);t.updateCacheSize(x,n)}}CanvasTileLayerRenderer.prototype.getLayer;export default CanvasTileLayerRenderer;
//# sourceMappingURL=/sm/26cfe0a1ab0bac62d0a2382ece9ab3674bf27e5a2381a4a007e65c5cc8ec200e.map