/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/renderer/webgl/TileLayer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import LRUCache from"../../structs/LRUCache.js";import State from"../../source/State.js";import TileRange from"../../TileRange.js";import TileState from"../../TileState.js";import TileTexture from"../../webgl/TileTexture.js";import WebGLArrayBuffer from"../../webgl/Buffer.js";import WebGLLayerRenderer from"./Layer.js";import{AttributeType}from"../../webgl/Helper.js";import{ELEMENT_ARRAY_BUFFER,STATIC_DRAW}from"../../webgl.js";import{compose as composeTransform,create as createTransform}from"../../transform.js";import{create as createMat4,fromTransform as mat4FromTransform}from"../../vec/mat4.js";import{createOrUpdate as createTileCoord,getKeyZXY,getKey as getTileCoordKey}from"../../tilecoord.js";import{fromUserExtent}from"../../proj.js";import{getIntersection}from"../../extent.js";import{getUid}from"../../util.js";import{isEmpty}from"../../extent.js";import{numberSafeCompareFunction}from"../../array.js";import{toSize}from"../../size.js";export const Uniforms={TILE_TEXTURE_ARRAY:"u_tileTextures",TILE_TRANSFORM:"u_tileTransform",TRANSITION_ALPHA:"u_transitionAlpha",DEPTH:"u_depth",TEXTURE_PIXEL_WIDTH:"u_texturePixelWidth",TEXTURE_PIXEL_HEIGHT:"u_texturePixelHeight",RESOLUTION:"u_resolution",ZOOM:"u_zoom"};export const Attributes={TEXTURE_COORD:"a_textureCoord"};const attributeDescriptions=[{name:Attributes.TEXTURE_COORD,size:2,type:AttributeType.FLOAT}],empty={};function depthForZ(e){return 2*(1-1/(e+1))-1}function addTileTextureToLookup(e,t,r){r in e||(e[r]=[]),e[r].push(t)}function getRenderExtent(e,t){const r=e.layerStatesArray[e.layerIndex];r.extent&&(t=getIntersection(t,fromUserExtent(r.extent,e.viewState.projection)));const i=r.layer.getSource();if(!i.getWrapX()){const r=i.getTileGridForProjection(e.viewState.projection).getExtent();r&&(t=getIntersection(t,r))}return t}class WebGLTileLayerRenderer extends WebGLLayerRenderer{constructor(e,t){super(e,{uniforms:t.uniforms}),this.tileTransform_=createTransform(),this.tempMat4_=createMat4(),this.tempTileRange_=new TileRange(0,0,0,0),this.tempTileCoord_=createTileCoord(0,0,0),this.tempSize_=[0,0],this.program_,this.vertexShader_=t.vertexShader,this.fragmentShader_=t.fragmentShader,this.indices_=new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER,STATIC_DRAW),this.indices_.fromArray([0,1,3,1,2,3]);const r=void 0!==t.cacheSize?t.cacheSize:512;this.tileTextureCache_=new LRUCache(r),this.paletteTextures_=t.paletteTextures||[]}reset(e){super.reset({uniforms:e.uniforms}),this.vertexShader_=e.vertexShader,this.fragmentShader_=e.fragmentShader,this.paletteTextures_=e.paletteTextures||[],this.helper&&(this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_))}afterHelperCreated(){this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_),this.helper.flushBufferData(this.indices_)}isDrawableTile_(e){const t=this.getLayer(),r=e.getState(),i=t.getUseInterimTilesOnError();return r==TileState.LOADED||r==TileState.EMPTY||r==TileState.ERROR&&!i}prepareFrameInternal(e){const t=this.getLayer().getSource();return!!t&&(!isEmpty(getRenderExtent(e,e.extent))&&t.getState()===State.READY)}enqueueTiles(e,t,r,i){const o=e.viewState,s=this.getLayer().getSource(),n=s.getTileGridForProjection(o.projection),a=this.tileTextureCache_,l=n.getTileRangeForExtentAndZ(t,r,this.tempTileRange_),h=getUid(s);h in e.wantedTiles||(e.wantedTiles[h]={});const T=e.wantedTiles[h],m=n.getResolution(r);for(let t=l.minX;t<=l.maxX;++t)for(let p=l.minY;p<=l.maxY;++p){const l=createTileCoord(r,t,p,this.tempTileCoord_),u=getTileCoordKey(l);let c,f;if(a.containsKey(u)&&(c=a.get(u),f=c.tile),!c||c.tile.key!==s.getKey())if(f=s.getTile(r,t,p,e.pixelRatio,o.projection),c)if(this.isDrawableTile_(f))c.setTile(f);else{const e=f.getInterimTile();c.setTile(e)}else c=new TileTexture(f,n,this.helper),a.set(u,c);addTileTextureToLookup(i,c,r);const d=f.getKey();T[d]=!0,f.getState()===TileState.IDLE&&(e.tileQueue.isKeyQueued(d)||e.tileQueue.enqueue([f,h,n.getTileCoordCenter(l),m]))}}renderFrame(e){const t=this.helper.getGL();this.preRender(t,e);const r=e.viewState,i=this.getLayer().getSource(),o=i.getTileGridForProjection(r.projection),s=getRenderExtent(e,e.extent),n=o.getZForResolution(r.resolution,i.zDirection),a={};if(e.nextExtent){const t=o.getZForResolution(r.nextResolution,i.zDirection),s=getRenderExtent(e,e.nextExtent);this.enqueueTiles(e,s,t,a)}this.enqueueTiles(e,s,n,a);const l={},h=getUid(this),T=e.time;let m=!1;const p=a[n];for(let e=0,t=p.length;e<t;++e){const t=p[e],r=t.tile,i=r.tileCoord;if(t.loaded){const e=r.getAlpha(h,T);if(1===e){r.endTransition(h);continue}m=!0;l[getTileCoordKey(i)]=e}if(this.findAltTiles_(o,i,n+1,a))continue;const s=o.getMinZoom();for(let e=n-1;e>=s;--e){if(this.findAltTiles_(o,i,e,a))break}}this.helper.useProgram(this.program_),this.helper.prepareDraw(e,!m);const u=Object.keys(a).map(Number).sort(numberSafeCompareFunction),c=r.center[0],f=r.center[1];for(let i=0,s=u.length;i<s;++i){const s=u[i],n=o.getResolution(s),h=toSize(o.getTileSize(s),this.tempSize_),T=o.getOrigin(s),m=(c-T[0])/(h[0]*n),p=(T[1]-f)/(h[1]*n),d=r.resolution/n,g=depthForZ(s),_=a[s];for(let i=0,o=_.length;i<o;++i){const o=_[i];if(!o.loaded)continue;const s=o.tile.tileCoord,n=getTileCoordKey(s),a=s[1],T=s[2];composeTransform(this.tileTransform_,0,0,2/(e.size[0]*d/h[0]),-2/(e.size[1]*d/h[1]),r.rotation,-(m-a),-(p-T)),this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM,mat4FromTransform(this.tempMat4_,this.tileTransform_)),this.helper.bindBuffer(o.coords),this.helper.bindBuffer(this.indices_),this.helper.enableAttributes(attributeDescriptions);let u=0;for(;u<o.textures.length;){const e="TEXTURE"+u,r=`${Uniforms.TILE_TEXTURE_ARRAY}[${u}]`;t.activeTexture(t[e]),t.bindTexture(t.TEXTURE_2D,o.textures[u]),t.uniform1i(this.helper.getUniformLocation(r),u),++u}for(let e=0;e<this.paletteTextures_.length;++e){const r=this.paletteTextures_[e];t.activeTexture(t["TEXTURE"+u]);const i=r.getTexture(t);t.bindTexture(t.TEXTURE_2D,i),t.uniform1i(this.helper.getUniformLocation(r.name),u),++u}const c=n in l?l[n]:1;c<1&&(e.animate=!0),this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA,c),this.helper.setUniformFloatValue(Uniforms.DEPTH,g),this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH,h[0]),this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT,h[1]),this.helper.setUniformFloatValue(Uniforms.RESOLUTION,r.resolution),this.helper.setUniformFloatValue(Uniforms.ZOOM,r.zoom),this.helper.drawElements(0,this.indices_.getSize())}}this.helper.finalizeDraw(e,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent);const d=this.helper.getCanvas(),g=this.tileTextureCache_;for(;g.canExpireCache();){g.pop().dispose()}return e.postRenderFunctions.push((function(e,t){i.expireCache(t.viewState.projection,empty)})),this.postRender(t,e),d}findAltTiles_(e,t,r,i){const o=e.getTileRangeForTileCoordAndZ(t,r,this.tempTileRange_);if(!o)return!1;let s=!0;const n=this.tileTextureCache_;for(let e=o.minX;e<=o.maxX;++e)for(let t=o.minY;t<=o.maxY;++t){const o=getKeyZXY(r,e,t);let a=!1;if(n.containsKey(o)){const e=n.get(o);e.loaded&&(addTileTextureToLookup(i,e,r),a=!0)}a||(s=!1)}return s}disposeInternal(){const e=this.helper,t=e.getGL();e.deleteBuffer(this.indices_),delete this.indices_,t.deleteProgram(this.program_),delete this.program_;const r=this.tileTextureCache_;r.forEach((function(e){e.dispose()})),r.clear(),delete this.tileTextureCache_,super.disposeInternal()}}WebGLTileLayerRenderer.prototype.getLayer;export default WebGLTileLayerRenderer;
//# sourceMappingURL=/sm/be4394450b0d733fe26cffbaf0133fceb32d4fc69e64f5539c97b22b8657d77c.map