/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/layer/Graticule.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Collection from"../Collection.js";import EventType from"../render/EventType.js";import Feature from"../Feature.js";import Fill from"../style/Fill.js";import GeometryLayout from"../geom/GeometryLayout.js";import LineString from"../geom/LineString.js";import Point from"../geom/Point.js";import Stroke from"../style/Stroke.js";import Style from"../style/Style.js";import Text from"../style/Text.js";import VectorLayer from"./Vector.js";import VectorSource from"../source/Vector.js";import{applyTransform,approximatelyEquals,containsCoordinate,containsExtent,equals,getCenter,getHeight,getIntersection,getWidth,intersects,isEmpty,wrapX as wrapExtentX}from"../extent.js";import{assign}from"../obj.js";import{clamp}from"../math.js";import{degreesToStringHDMS}from"../coordinate.js";import{equivalent as equivalentProjection,get as getProjection,getTransform}from"../proj.js";import{getVectorContext}from"../render.js";import{meridian,parallel}from"../geom/flat/geodesic.js";const DEFAULT_STROKE_STYLE=new Stroke({color:"rgba(0,0,0,0.2)"}),INTERVALS=[90,45,30,20,10,5,2,1,.5,.2,.1,.05,.01,.005,.002,.001];class Graticule extends VectorLayer{constructor(t){const e=t||{},i=assign({updateWhileAnimating:!0,updateWhileInteracting:!0,renderBuffer:0},e);delete i.maxLines,delete i.strokeStyle,delete i.targetSize,delete i.showLabels,delete i.lonLabelFormatter,delete i.latLabelFormatter,delete i.lonLabelPosition,delete i.latLabelPosition,delete i.lonLabelStyle,delete i.latLabelStyle,delete i.intervals,super(i),this.projection_=null,this.maxLat_=1/0,this.maxLon_=1/0,this.minLat_=-1/0,this.minLon_=-1/0,this.maxX_=1/0,this.maxY_=1/0,this.minX_=-1/0,this.minY_=-1/0,this.targetSize_=void 0!==e.targetSize?e.targetSize:100,this.maxLines_=void 0!==e.maxLines?e.maxLines:100,this.meridians_=[],this.parallels_=[],this.strokeStyle_=void 0!==e.strokeStyle?e.strokeStyle:DEFAULT_STROKE_STYLE,this.fromLonLatTransform_=void 0,this.toLonLatTransform_=void 0,this.projectionCenterLonLat_=null,this.bottomLeft_=null,this.bottomRight_=null,this.topLeft_=null,this.topRight_=null,this.meridiansLabels_=null,this.parallelsLabels_=null,e.showLabels&&(this.lonLabelFormatter_=null==e.lonLabelFormatter?degreesToStringHDMS.bind(this,"EW"):e.lonLabelFormatter,this.latLabelFormatter_=null==e.latLabelFormatter?degreesToStringHDMS.bind(this,"NS"):e.latLabelFormatter,this.lonLabelPosition_=null==e.lonLabelPosition?0:e.lonLabelPosition,this.latLabelPosition_=null==e.latLabelPosition?1:e.latLabelPosition,this.lonLabelStyleBase_=new Style({text:void 0!==e.lonLabelStyle?e.lonLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.lonLabelStyle_=function(t){const e=t.get("graticule_label");return this.lonLabelStyleBase_.getText().setText(e),this.lonLabelStyleBase_}.bind(this),this.latLabelStyleBase_=new Style({text:void 0!==e.latLabelStyle?e.latLabelStyle.clone():new Text({font:"12px Calibri,sans-serif",textAlign:"right",fill:new Fill({color:"rgba(0,0,0,1)"}),stroke:new Stroke({color:"rgba(255,255,255,1)",width:3})})}),this.latLabelStyle_=function(t){const e=t.get("graticule_label");return this.latLabelStyleBase_.getText().setText(e),this.latLabelStyleBase_}.bind(this),this.meridiansLabels_=[],this.parallelsLabels_=[],this.addEventListener(EventType.POSTRENDER,this.drawLabels_.bind(this))),this.intervals_=void 0!==e.intervals?e.intervals:INTERVALS,this.setSource(new VectorSource({loader:this.loaderFunction.bind(this),strategy:this.strategyFunction.bind(this),features:new Collection,overlaps:!1,useSpatialIndex:!1,wrapX:e.wrapX})),this.featurePool_=[],this.lineStyle_=new Style({stroke:this.strokeStyle_}),this.loadedExtent_=null,this.renderedExtent_=null,this.setRenderOrder(null)}strategyFunction(t,e){let i=t.slice();return this.projection_&&this.getSource().getWrapX()&&wrapExtentX(i,this.projection_),this.loadedExtent_&&(approximatelyEquals(this.loadedExtent_,i,e)?i=this.loadedExtent_.slice():this.getSource().removeLoadedExtent(this.loadedExtent_)),[i]}loaderFunction(t,e,i){this.loadedExtent_=t;const a=this.getSource(),s=this.getExtent()||[-1/0,-1/0,1/0,1/0],n=getIntersection(s,t);if(this.renderedExtent_&&equals(this.renderedExtent_,n))return;if(this.renderedExtent_=n,isEmpty(n))return;const o=getCenter(n),l=e*e/4;(!this.projection_||!equivalentProjection(this.projection_,i))&&this.updateProjectionInfo_(i),this.createGraticule_(n,o,e,l);let r,h=this.meridians_.length+this.parallels_.length;for(this.meridiansLabels_&&(h+=this.meridians_.length),this.parallelsLabels_&&(h+=this.parallels_.length);h>this.featurePool_.length;)r=new Feature,this.featurePool_.push(r);const _=a.getFeaturesCollection();_.clear();let m,L,d=0;for(m=0,L=this.meridians_.length;m<L;++m)r=this.featurePool_[d++],r.setGeometry(this.meridians_[m]),r.setStyle(this.lineStyle_),_.push(r);for(m=0,L=this.parallels_.length;m<L;++m)r=this.featurePool_[d++],r.setGeometry(this.parallels_[m]),r.setStyle(this.lineStyle_),_.push(r)}addMeridian_(t,e,i,a,s,n){const o=this.getMeridian_(t,e,i,a,n);if(intersects(o.getExtent(),s)){if(this.meridiansLabels_){const e=this.lonLabelFormatter_(t);n in this.meridiansLabels_?this.meridiansLabels_[n].text=e:this.meridiansLabels_[n]={geom:new Point([]),text:e}}this.meridians_[n++]=o}return n}addParallel_(t,e,i,a,s,n){const o=this.getParallel_(t,e,i,a,n);if(intersects(o.getExtent(),s)){if(this.parallelsLabels_){const e=this.latLabelFormatter_(t);n in this.parallelsLabels_?this.parallelsLabels_[n].text=e:this.parallelsLabels_[n]={geom:new Point([]),text:e}}this.parallels_[n++]=o}return n}drawLabels_(t){const e=t.frameState.viewState.rotation,i=t.frameState.extent,a=getCenter(i);let s=i;if(e){const t=getWidth(i),n=getHeight(i),o=Math.abs(Math.cos(e)),l=Math.abs(Math.sin(e)),r=(l*n-o*t)/(l*l-o*o),h=(l*t-o*n)/(l*l-o*o);s=[a[0]-r/2,a[1]-h/2,a[0]+r/2,a[1]+h/2]}let n=0,o=0,l=this.latLabelPosition_<.5;const r=this.projection_.getExtent(),h=getWidth(r);if(this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(r,i)){n=Math.floor((i[0]-r[0])/h),o=Math.ceil((i[2]-r[2])/h);l=l!==Math.abs(e)>Math.PI/2}const _=getVectorContext(t);for(let t=n;t<=o;++t){let r,m,L,d,c=this.meridians_.length+this.parallels_.length;if(this.meridiansLabels_)for(m=0,L=this.meridiansLabels_.length;m<L;++m){const n=this.meridians_[m];if(e||0!==t){const i=n.clone();i.translate(t*h,0),i.rotate(-e,a),d=this.getMeridianPoint_(i,s,m),d.rotate(e,a)}else d=this.getMeridianPoint_(n,i,m);r=this.featurePool_[c++],r.setGeometry(d),r.set("graticule_label",this.meridiansLabels_[m].text),_.drawFeature(r,this.lonLabelStyle_(r))}if(this.parallelsLabels_&&(t===n&&l||t===o&&!l))for(m=0,L=this.parallels_.length;m<L;++m){const n=this.parallels_[m];if(e||0!==t){const i=n.clone();i.translate(t*h,0),i.rotate(-e,a),d=this.getParallelPoint_(i,s,m),d.rotate(e,a)}else d=this.getParallelPoint_(n,i,m);r=this.featurePool_[c++],r.setGeometry(d),r.set("graticule_label",this.parallelsLabels_[m].text),_.drawFeature(r,this.latLabelStyle_(r))}}}createGraticule_(t,e,i,a){const s=this.getInterval_(i);if(-1==s)return this.meridians_.length=0,this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),void(this.parallelsLabels_&&(this.parallelsLabels_.length=0));let n=!1;const o=this.projection_.getExtent(),l=getWidth(o);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!containsExtent(o,t)&&(getWidth(t)>=l?(t[0]=o[0],t[2]=o[2]):n=!0);const r=[clamp(e[0],this.minX_,this.maxX_),clamp(e[1],this.minY_,this.maxY_)],h=this.toLonLatTransform_(r);isNaN(h[1])&&(h[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_);let _=clamp(h[0],this.minLon_,this.maxLon_),m=clamp(h[1],this.minLat_,this.maxLat_);const L=this.maxLines_;let d,c,p,g,f=t;n||(f=[clamp(t[0],this.minX_,this.maxX_),clamp(t[1],this.minY_,this.maxY_),clamp(t[2],this.minX_,this.maxX_),clamp(t[3],this.minY_,this.maxY_)]);const b=applyTransform(f,this.toLonLatTransform_,void 0,8);let x=b[3],u=b[2],S=b[1],y=b[0];if(n||(containsCoordinate(f,this.bottomLeft_)&&(y=this.minLon_,S=this.minLat_),containsCoordinate(f,this.bottomRight_)&&(u=this.maxLon_,S=this.minLat_),containsCoordinate(f,this.topLeft_)&&(y=this.minLon_,x=this.maxLat_),containsCoordinate(f,this.topRight_)&&(u=this.maxLon_,x=this.maxLat_),x=clamp(x,m,this.maxLat_),u=clamp(u,_,this.maxLon_),S=clamp(S,this.minLat_,m),y=clamp(y,this.minLon_,_)),_=Math.floor(_/s)*s,g=clamp(_,this.minLon_,this.maxLon_),c=this.addMeridian_(g,S,x,a,t,0),d=0,n)for(;(g-=s)>=y&&d++<L;)c=this.addMeridian_(g,S,x,a,t,c);else for(;g!=this.minLon_&&d++<L;)g=Math.max(g-s,this.minLon_),c=this.addMeridian_(g,S,x,a,t,c);if(g=clamp(_,this.minLon_,this.maxLon_),d=0,n)for(;(g+=s)<=u&&d++<L;)c=this.addMeridian_(g,S,x,a,t,c);else for(;g!=this.maxLon_&&d++<L;)g=Math.min(g+s,this.maxLon_),c=this.addMeridian_(g,S,x,a,t,c);for(this.meridians_.length=c,this.meridiansLabels_&&(this.meridiansLabels_.length=c),m=Math.floor(m/s)*s,p=clamp(m,this.minLat_,this.maxLat_),c=this.addParallel_(p,y,u,a,t,0),d=0;p!=this.minLat_&&d++<L;)p=Math.max(p-s,this.minLat_),c=this.addParallel_(p,y,u,a,t,c);for(p=clamp(m,this.minLat_,this.maxLat_),d=0;p!=this.maxLat_&&d++<L;)p=Math.min(p+s,this.maxLat_),c=this.addParallel_(p,y,u,a,t,c);this.parallels_.length=c,this.parallelsLabels_&&(this.parallelsLabels_.length=c)}getInterval_(t){const e=this.projectionCenterLonLat_[0],i=this.projectionCenterLonLat_[1];let a=-1;const s=Math.pow(this.targetSize_*t,2),n=[],o=[];for(let t=0,l=this.intervals_.length;t<l;++t){const l=clamp(this.intervals_[t]/2,0,90),r=clamp(i,-90+l,90-l);n[0]=e-l,n[1]=r-l,o[0]=e+l,o[1]=r+l,this.fromLonLatTransform_(n,n),this.fromLonLatTransform_(o,o);if(Math.pow(o[0]-n[0],2)+Math.pow(o[1]-n[1],2)<=s)break;a=this.intervals_[t]}return a}getMeridian_(t,e,i,a,s){const n=meridian(t,e,i,this.projection_,a);let o=this.meridians_[s];return o?(o.setFlatCoordinates(GeometryLayout.XY,n),o.changed()):(o=new LineString(n,GeometryLayout.XY),this.meridians_[s]=o),o}getMeridianPoint_(t,e,i){const a=t.getFlatCoordinates();let s=1,n=a.length-1;a[s]>a[n]&&(s=n,n=1);const o=Math.max(e[1],a[s]),l=Math.min(e[3],a[n]),r=clamp(e[1]+Math.abs(e[1]-e[3])*this.lonLabelPosition_,o,l),h=[a[s-1]+(a[n-1]-a[s-1])*(r-a[s])/(a[n]-a[s]),r],_=this.meridiansLabels_[i].geom;return _.setCoordinates(h),_}getMeridians(){return this.meridians_}getParallel_(t,e,i,a,s){const n=parallel(t,e,i,this.projection_,a);let o=this.parallels_[s];return o?(o.setFlatCoordinates(GeometryLayout.XY,n),o.changed()):o=new LineString(n,GeometryLayout.XY),o}getParallelPoint_(t,e,i){const a=t.getFlatCoordinates();let s=0,n=a.length-2;a[s]>a[n]&&(s=n,n=0);const o=Math.max(e[0],a[s]),l=Math.min(e[2],a[n]),r=clamp(e[0]+Math.abs(e[0]-e[2])*this.latLabelPosition_,o,l),h=[r,a[s+1]+(a[n+1]-a[s+1])*(r-a[s])/(a[n]-a[s])],_=this.parallelsLabels_[i].geom;return _.setCoordinates(h),_}getParallels(){return this.parallels_}updateProjectionInfo_(t){const e=getProjection("EPSG:4326"),i=t.getWorldExtent();this.maxLat_=i[3],this.maxLon_=i[2],this.minLat_=i[1],this.minLon_=i[0];const a=getTransform(t,e);if(this.minLon_<this.maxLon_)this.toLonLatTransform_=a;else{const t=this.minLon_+this.maxLon_/2;this.maxLon_+=360,this.toLonLatTransform_=function(e,i,s){const n=s||2,o=a(e,i,n);for(let e=0,i=o.length;e<i;e+=n)o[e]<t&&(o[e]+=360);return o}}this.fromLonLatTransform_=getTransform(e,t);const s=applyTransform([this.minLon_,this.minLat_,this.maxLon_,this.maxLat_],this.fromLonLatTransform_,void 0,8);this.minX_=s[0],this.maxX_=s[2],this.minY_=s[1],this.maxY_=s[3],this.bottomLeft_=this.fromLonLatTransform_([this.minLon_,this.minLat_]),this.bottomRight_=this.fromLonLatTransform_([this.maxLon_,this.minLat_]),this.topLeft_=this.fromLonLatTransform_([this.minLon_,this.maxLat_]),this.topRight_=this.fromLonLatTransform_([this.maxLon_,this.maxLat_]),this.projectionCenterLonLat_=this.toLonLatTransform_(getCenter(t.getExtent())),isNaN(this.projectionCenterLonLat_[1])&&(this.projectionCenterLonLat_[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_),this.projection_=t}}export default Graticule;
//# sourceMappingURL=/sm/d2f6300555e9f7964e8fdb5be300d3fbd7ce6d50c453bdb7d7461e761d697378.map