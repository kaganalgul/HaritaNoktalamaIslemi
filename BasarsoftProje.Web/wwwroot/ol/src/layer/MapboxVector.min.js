/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/layer/MapboxVector.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseEvent from"../events/Event.js";import EventType from"../events/EventType.js";import MVT from"../format/MVT.js";import SourceState from"../source/State.js";import VectorTileLayer from"../layer/VectorTile.js";import VectorTileSource from"../source/VectorTile.js";import{applyBackground,applyStyle,setupVectorSource}from"ol-mapbox-style";const mapboxBaseUrl="https://api.mapbox.com";export function getMapboxPath(e){const t="mapbox://";return 0!==e.indexOf(t)?"":e.slice(t.length)}export function normalizeSpriteUrl(e,t,r){const o=getMapboxPath(e);if(!o)return decodeURI(new URL(e,r).href);const s="sprites/";if(0!==o.indexOf(s))throw new Error(`unexpected sprites url: ${e}`);const n=o.slice(s.length);return`${mapboxBaseUrl}/styles/v1/${n}/sprite?access_token=${t}`}export function normalizeGlyphsUrl(e,t,r){const o=getMapboxPath(e);if(!o)return decodeURI(new URL(e,r).href);const s="fonts/";if(0!==o.indexOf(s))throw new Error(`unexpected fonts url: ${e}`);const n=o.slice(s.length);return`${mapboxBaseUrl}/fonts/v1/${n}/0-255.pbf?access_token=${t}`}export function normalizeStyleUrl(e,t){const r=getMapboxPath(e);if(!r)return decodeURI(new URL(e,location.href).href);const o="styles/";if(0!==r.indexOf(o))throw new Error(`unexpected style url: ${e}`);const s=r.slice(o.length);return`${mapboxBaseUrl}/styles/v1/${s}?&access_token=${t}`}export function normalizeSourceUrl(e,t,r,o){const s=new URL(e,o),n=getMapboxPath(e);return n?`https://{a-d}.tiles.mapbox.com/v4/${n}/{z}/{x}/{y}.vector.pbf?access_token=${t}`:t?(s.searchParams.set(r,t),decodeURI(s.href)):decodeURI(s.href)}class ErrorEvent extends BaseEvent{constructor(e){super(EventType.ERROR),this.error=e}}const SourceType={VECTOR:"vector"};class MapboxVectorLayer extends VectorTileLayer{constructor(e){const t=!("declutter"in e)||e.declutter;if(super({source:new VectorTileSource({state:SourceState.LOADING,format:new MVT}),background:e.background,declutter:t,className:e.className,opacity:e.opacity,visible:e.visible,zIndex:e.zIndex,minResolution:e.minResolution,maxResolution:e.maxResolution,minZoom:e.minZoom,maxZoom:e.maxZoom,renderOrder:e.renderOrder,renderBuffer:e.renderBuffer,renderMode:e.renderMode,map:e.map,updateWhileAnimating:e.updateWhileAnimating,updateWhileInteracting:e.updateWhileInteracting,preload:e.preload,useInterimTilesOnError:e.useInterimTilesOnError,properties:e.properties}),this.setMaxResolutionFromTileGrid_=void 0===e.maxResolution&&void 0===e.minZoom,this.sourceId=e.source,this.layers=e.layers,e.accessToken)this.accessToken=e.accessToken;else{new URL(e.styleUrl,location.href).searchParams.forEach(((e,t)=>{this.accessToken=e,this.accessTokenParam_=t}))}this.fetchStyle(e.styleUrl)}fetchStyle(e){const t=normalizeStyleUrl(e,this.accessToken);fetch(t).then((e=>{if(!e.ok)throw new Error(`unexpected response when fetching style: ${e.status}`);return e.json()})).then((e=>{this.onStyleLoad(e,t.startsWith("data:")?location.href:t)})).catch((e=>{this.handleError(e)}))}onStyleLoad(e,t){let r,o;if(this.layers){const t={};for(let r=0;r<e.layers.length;++r){const o=e.layers[r];o.source&&(t[o.id]=o.source)}let s;for(let e=0;e<this.layers.length;++e){const r=t[this.layers[e]];if(!r)return void this.handleError(new Error(`could not find source for ${this.layers[e]}`));if(s){if(s!==r)return void this.handleError(new Error(`layers can only use a single source, found ${s} and ${r}`))}else s=r}r=s,o=this.layers}else r=this.sourceId,o=r;o||(r=Object.keys(e.sources)[0],o=r),e.sprite&&(e.sprite=normalizeSpriteUrl(e.sprite,this.accessToken,t)),e.glyphs&&(e.glyphs=normalizeGlyphsUrl(e.glyphs,this.accessToken,t));const s=e.sources[r];if(s.type!==SourceType.VECTOR)return void this.handleError(new Error(`only works for vector sources, found ${s.type}`));const n=this.getSource();s.url&&0===s.url.indexOf("mapbox://")?(n.setUrl(normalizeSourceUrl(s.url,this.accessToken,this.accessTokenParam_,t)),applyStyle(this,e,o).then((()=>{this.configureSource(n,e)})).catch((e=>{this.handleError(e)}))):(s.tiles&&(s.tiles=s.tiles.map((e=>normalizeSourceUrl(e,this.accessToken,this.accessTokenParam_,t)))),setupVectorSource(s,s.url?normalizeSourceUrl(s.url,this.accessToken,this.accessTokenParam_,t):void 0).then((t=>{applyStyle(this,e,o).then((()=>{this.configureSource(t,e)})).catch((r=>{this.configureSource(t,e),this.handleError(r)}))})))}configureSource(e,t){const r=this.getSource();if(e!==r&&(r.setAttributions(e.getAttributions()),r.setTileUrlFunction(e.getTileUrlFunction()),r.setTileLoadFunction(e.getTileLoadFunction()),r.tileGrid=e.tileGrid),void 0===this.getBackground()&&applyBackground(this,t),this.setMaxResolutionFromTileGrid_){const e=r.getTileGrid();this.setMaxResolution(e.getResolution(e.getMinZoom()))}r.setState(SourceState.READY)}handleError(e){this.dispatchEvent(new ErrorEvent(e));this.getSource().setState(SourceState.ERROR)}}export default MapboxVectorLayer;
//# sourceMappingURL=/sm/77e21695b85803e212f2bd52aa580e4c2fa9d87a44383f22c0e1ee18e42a5056.map