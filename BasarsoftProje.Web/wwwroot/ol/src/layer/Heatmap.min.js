/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/layer/Heatmap.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseVector from"./BaseVector.js";import WebGLPointsLayerRenderer from"../renderer/webgl/PointsLayer.js";import{assign}from"../obj.js";import{clamp}from"../math.js";import{createCanvasContext2D}from"../dom.js";const Property={BLUR:"blur",GRADIENT:"gradient",RADIUS:"radius"},DEFAULT_GRADIENT=["#00f","#0ff","#0f0","#ff0","#f00"];class Heatmap extends BaseVector{constructor(t){const e=t||{},n=assign({},e);delete n.gradient,delete n.radius,delete n.blur,delete n.weight,super(n),this.gradient_=null,this.addChangeListener(Property.GRADIENT,this.handleGradientChanged_),this.setGradient(e.gradient?e.gradient:DEFAULT_GRADIENT),this.setBlur(void 0!==e.blur?e.blur:15),this.setRadius(void 0!==e.radius?e.radius:8);const i=e.weight?e.weight:"weight";this.weightFunction_="string"==typeof i?function(t){return t.get(i)}:i,this.setRenderOrder(null)}getBlur(){return this.get(Property.BLUR)}getGradient(){return this.get(Property.GRADIENT)}getRadius(){return this.get(Property.RADIUS)}handleGradientChanged_(){this.gradient_=createGradient(this.getGradient())}setBlur(t){this.set(Property.BLUR,t)}setGradient(t){this.set(Property.GRADIENT,t)}setRadius(t){this.set(Property.RADIUS,t)}createRenderer(){return new WebGLPointsLayerRenderer(this,{className:this.getClassName(),attributes:[{name:"weight",callback:function(t){const e=this.weightFunction_(t);return void 0!==e?clamp(e,0,1):1}.bind(this)}],vertexShader:"\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",fragmentShader:"\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",hitVertexShader:"\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",hitFragmentShader:"\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",uniforms:{u_size:function(){return 2*(this.get(Property.RADIUS)+this.get(Property.BLUR))}.bind(this),u_blurSlope:function(){return this.get(Property.RADIUS)/Math.max(1,this.get(Property.BLUR))}.bind(this)},postProcesses:[{fragmentShader:"\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",uniforms:{u_gradientTexture:function(){return this.gradient_}.bind(this),u_opacity:function(){return this.getOpacity()}.bind(this)}}]})}renderDeclutter(){}}function createGradient(t){const e=createCanvasContext2D(1,256),n=e.createLinearGradient(0,0,1,256),i=1/(t.length-1);for(let e=0,r=t.length;e<r;++e)n.addColorStop(e*i,t[e]);return e.fillStyle=n,e.fillRect(0,0,1,256),e.canvas}export default Heatmap;
//# sourceMappingURL=/sm/8b3ee487b309cd02f82ded2d213da8939cfc7e312584172c3c4fa43c983dc8f6.map