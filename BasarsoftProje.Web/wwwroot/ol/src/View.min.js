/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/View.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BaseObject from"./Object.js";import GeometryType from"./geom/GeometryType.js";import Units from"./proj/Units.js";import ViewHint from"./ViewHint.js";import ViewProperty from"./ViewProperty.js";import{DEFAULT_TILE_SIZE}from"./tilegrid/common.js";import{METERS_PER_UNIT,createProjection,fromUserCoordinate,fromUserExtent,getUserProjection,toUserCoordinate,toUserExtent}from"./proj.js";import{VOID}from"./functions.js";import{add as addCoordinate,equals as coordinatesEqual,rotate as rotateCoordinate}from"./coordinate.js";import{assert}from"./asserts.js";import{assign}from"./obj.js";import{none as centerNone,createExtent}from"./centerconstraint.js";import{clamp,modulo}from"./math.js";import{createMinMaxResolution}from"./resolutionconstraint.js";import{createSnapToN,createSnapToZero,disable,none as rotationNone}from"./rotationconstraint.js";import{createSnapToPower,createSnapToResolutions}from"./resolutionconstraint.js";import{easeOut}from"./easing.js";import{equals}from"./coordinate.js";import{getCenter,getForViewAndSize,getHeight,getWidth,isEmpty}from"./extent.js";import{inAndOut}from"./easing.js";import{linearFindNearest}from"./array.js";import{fromExtent as polygonFromExtent}from"./geom/Polygon.js";const DEFAULT_MIN_ZOOM=0;class View extends BaseObject{constructor(t){super(),this.on,this.once,this.un;const e=assign({},t);this.hints_=[0,0],this.animations_=[],this.updateAnimationKey_,this.projection_=createProjection(e.projection,"EPSG:3857"),this.viewportSize_=[100,100],this.targetCenter_=null,this.targetResolution_,this.targetRotation_,this.nextCenter_=null,this.nextResolution_,this.nextRotation_,this.cancelAnchor_=void 0,e.center&&(e.center=fromUserCoordinate(e.center,this.projection_)),e.extent&&(e.extent=fromUserExtent(e.extent,this.projection_)),this.applyOptions_(e)}applyOptions_(t){const e=assign({},t);for(const t in ViewProperty)delete e[t];this.setProperties(e,!0);const o=createResolutionConstraint(t);this.maxResolution_=o.maxResolution,this.minResolution_=o.minResolution,this.zoomFactor_=o.zoomFactor,this.resolutions_=t.resolutions,this.padding_=t.padding,this.minZoom_=o.minZoom;const n=createCenterConstraint(t),i=o.constraint,s=createRotationConstraint(t);this.constraints_={center:n,resolution:i,rotation:s},this.setRotation(void 0!==t.rotation?t.rotation:0),this.setCenterInternal(void 0!==t.center?t.center:null),void 0!==t.resolution?this.setResolution(t.resolution):void 0!==t.zoom&&this.setZoom(t.zoom)}get padding(){return this.padding_}set padding(t){let e=this.padding_;this.padding_=t;const o=this.getCenter();if(o){const n=t||[0,0,0,0];e=e||[0,0,0,0];const i=this.getResolution(),s=i/2*(n[3]-e[3]+e[1]-n[1]),r=i/2*(n[0]-e[0]+e[2]-n[2]);this.setCenterInternal([o[0]+s,o[1]-r])}}getUpdatedOptions_(t){const e=this.getProperties();return void 0!==e.resolution?e.resolution=this.getResolution():e.zoom=this.getZoom(),e.center=this.getCenterInternal(),e.rotation=this.getRotation(),assign({},e,t)}animate(t){this.isDef()&&!this.getAnimating()&&this.resolveConstraints(0);const e=new Array(arguments.length);for(let t=0;t<e.length;++t){let o=arguments[t];o.center&&(o=assign({},o),o.center=fromUserCoordinate(o.center,this.getProjection())),o.anchor&&(o=assign({},o),o.anchor=fromUserCoordinate(o.anchor,this.getProjection())),e[t]=o}this.animateInternal.apply(this,e)}animateInternal(t){let e,o=arguments.length;o>1&&"function"==typeof arguments[o-1]&&(e=arguments[o-1],--o);let n=0;for(;n<o&&!this.isDef();++n){const t=arguments[n];t.center&&this.setCenterInternal(t.center),void 0!==t.zoom?this.setZoom(t.zoom):t.resolution&&this.setResolution(t.resolution),void 0!==t.rotation&&this.setRotation(t.rotation)}if(n===o)return void(e&&animationCallback(e,!0));let i=Date.now(),s=this.targetCenter_.slice(),r=this.targetResolution_,a=this.targetRotation_;const h=[];for(;n<o;++n){const t=arguments[n],o={start:i,complete:!1,anchor:t.anchor,duration:void 0!==t.duration?t.duration:1e3,easing:t.easing||inAndOut,callback:e};if(t.center&&(o.sourceCenter=s,o.targetCenter=t.center.slice(),s=o.targetCenter),void 0!==t.zoom?(o.sourceResolution=r,o.targetResolution=this.getResolutionForZoom(t.zoom),r=o.targetResolution):t.resolution&&(o.sourceResolution=r,o.targetResolution=t.resolution,r=o.targetResolution),void 0!==t.rotation){o.sourceRotation=a;const e=modulo(t.rotation-a+Math.PI,2*Math.PI)-Math.PI;o.targetRotation=a+e,a=o.targetRotation}isNoopAnimation(o)?o.complete=!0:i+=o.duration,h.push(o)}this.animations_.push(h),this.setHint(ViewHint.ANIMATING,1),this.updateAnimations_()}getAnimating(){return this.hints_[ViewHint.ANIMATING]>0}getInteracting(){return this.hints_[ViewHint.INTERACTING]>0}cancelAnimations(){let t;this.setHint(ViewHint.ANIMATING,-this.hints_[ViewHint.ANIMATING]);for(let e=0,o=this.animations_.length;e<o;++e){const o=this.animations_[e];if(o[0].callback&&animationCallback(o[0].callback,!1),!t)for(let e=0,n=o.length;e<n;++e){const n=o[e];if(!n.complete){t=n.anchor;break}}}this.animations_.length=0,this.cancelAnchor_=t,this.nextCenter_=null,this.nextResolution_=NaN,this.nextRotation_=NaN}updateAnimations_(){if(void 0!==this.updateAnimationKey_&&(cancelAnimationFrame(this.updateAnimationKey_),this.updateAnimationKey_=void 0),!this.getAnimating())return;const t=Date.now();let e=!1;for(let o=this.animations_.length-1;o>=0;--o){const n=this.animations_[o];let i=!0;for(let o=0,s=n.length;o<s;++o){const s=n[o];if(s.complete)continue;const r=t-s.start;let a=s.duration>0?r/s.duration:1;a>=1?(s.complete=!0,a=1):i=!1;const h=s.easing(a);if(s.sourceCenter){const t=s.sourceCenter[0],e=s.sourceCenter[1],o=s.targetCenter[0],n=s.targetCenter[1];this.nextCenter_=s.targetCenter;const i=t+h*(o-t),r=e+h*(n-e);this.targetCenter_=[i,r]}if(s.sourceResolution&&s.targetResolution){const t=1===h?s.targetResolution:s.sourceResolution+h*(s.targetResolution-s.sourceResolution);if(s.anchor){const e=this.getViewportSize_(this.getRotation()),o=this.constraints_.resolution(t,0,e,!0);this.targetCenter_=this.calculateCenterZoom(o,s.anchor)}this.nextResolution_=s.targetResolution,this.targetResolution_=t,this.applyTargetState_(!0)}if(void 0!==s.sourceRotation&&void 0!==s.targetRotation){const t=1===h?modulo(s.targetRotation+Math.PI,2*Math.PI)-Math.PI:s.sourceRotation+h*(s.targetRotation-s.sourceRotation);if(s.anchor){const e=this.constraints_.rotation(t,!0);this.targetCenter_=this.calculateCenterRotate(e,s.anchor)}this.nextRotation_=s.targetRotation,this.targetRotation_=t}if(this.applyTargetState_(!0),e=!0,!s.complete)break}if(i){this.animations_[o]=null,this.setHint(ViewHint.ANIMATING,-1),this.nextCenter_=null,this.nextResolution_=NaN,this.nextRotation_=NaN;const t=n[0].callback;t&&animationCallback(t,!0)}}this.animations_=this.animations_.filter(Boolean),e&&void 0===this.updateAnimationKey_&&(this.updateAnimationKey_=requestAnimationFrame(this.updateAnimations_.bind(this)))}calculateCenterRotate(t,e){let o;const n=this.getCenterInternal();return void 0!==n&&(o=[n[0]-e[0],n[1]-e[1]],rotateCoordinate(o,t-this.getRotation()),addCoordinate(o,e)),o}calculateCenterZoom(t,e){let o;const n=this.getCenterInternal(),i=this.getResolution();if(void 0!==n&&void 0!==i){o=[e[0]-t*(e[0]-n[0])/i,e[1]-t*(e[1]-n[1])/i]}return o}getViewportSize_(t){const e=this.viewportSize_;if(t){const o=e[0],n=e[1];return[Math.abs(o*Math.cos(t))+Math.abs(n*Math.sin(t)),Math.abs(o*Math.sin(t))+Math.abs(n*Math.cos(t))]}return e}setViewportSize(t){this.viewportSize_=Array.isArray(t)?t.slice():[100,100],this.getAnimating()||this.resolveConstraints(0)}getCenter(){const t=this.getCenterInternal();return t?toUserCoordinate(t,this.getProjection()):t}getCenterInternal(){return this.get(ViewProperty.CENTER)}getConstraints(){return this.constraints_}getConstrainResolution(){return this.get("constrainResolution")}getHints(t){return void 0!==t?(t[0]=this.hints_[0],t[1]=this.hints_[1],t):this.hints_.slice()}calculateExtent(t){const e=this.calculateExtentInternal(t);return toUserExtent(e,this.getProjection())}calculateExtentInternal(t){const e=t||this.getViewportSizeMinusPadding_(),o=this.getCenterInternal();assert(o,1);const n=this.getResolution();assert(void 0!==n,2);const i=this.getRotation();return assert(void 0!==i,3),getForViewAndSize(o,n,i,e)}getMaxResolution(){return this.maxResolution_}getMinResolution(){return this.minResolution_}getMaxZoom(){return this.getZoomForResolution(this.minResolution_)}setMaxZoom(t){this.applyOptions_(this.getUpdatedOptions_({maxZoom:t}))}getMinZoom(){return this.getZoomForResolution(this.maxResolution_)}setMinZoom(t){this.applyOptions_(this.getUpdatedOptions_({minZoom:t}))}setConstrainResolution(t){this.applyOptions_(this.getUpdatedOptions_({constrainResolution:t}))}getProjection(){return this.projection_}getResolution(){return this.get(ViewProperty.RESOLUTION)}getResolutions(){return this.resolutions_}getResolutionForExtent(t,e){return this.getResolutionForExtentInternal(fromUserExtent(t,this.getProjection()),e)}getResolutionForExtentInternal(t,e){const o=e||this.getViewportSizeMinusPadding_(),n=getWidth(t)/o[0],i=getHeight(t)/o[1];return Math.max(n,i)}getResolutionForValueFunction(t){const e=t||2,o=this.getConstrainedResolution(this.maxResolution_),n=this.minResolution_,i=Math.log(o/n)/Math.log(e);return function(t){return o/Math.pow(e,t*i)}}getRotation(){return this.get(ViewProperty.ROTATION)}getValueForResolutionFunction(t){const e=Math.log(t||2),o=this.getConstrainedResolution(this.maxResolution_),n=this.minResolution_,i=Math.log(o/n)/e;return function(t){return Math.log(o/t)/e/i}}getViewportSizeMinusPadding_(t){let e=this.getViewportSize_(t);const o=this.padding_;return o&&(e=[e[0]-o[1]-o[3],e[1]-o[0]-o[2]]),e}getState(){const t=this.getProjection(),e=this.getResolution(),o=this.getRotation();let n=this.getCenterInternal();const i=this.padding_;if(i){const t=this.getViewportSizeMinusPadding_();n=calculateCenterOn(n,this.getViewportSize_(),[t[0]/2+i[3],t[1]/2+i[0]],e,o)}return{center:n.slice(0),projection:void 0!==t?t:null,resolution:e,nextCenter:this.nextCenter_,nextResolution:this.nextResolution_,nextRotation:this.nextRotation_,rotation:o,zoom:this.getZoom()}}getZoom(){let t;const e=this.getResolution();return void 0!==e&&(t=this.getZoomForResolution(e)),t}getZoomForResolution(t){let e,o,n=this.minZoom_||0;if(this.resolutions_){const i=linearFindNearest(this.resolutions_,t,1);n=i,e=this.resolutions_[i],o=i==this.resolutions_.length-1?2:e/this.resolutions_[i+1]}else e=this.maxResolution_,o=this.zoomFactor_;return n+Math.log(e/t)/Math.log(o)}getResolutionForZoom(t){if(this.resolutions_){if(this.resolutions_.length<=1)return 0;const e=clamp(Math.floor(t),0,this.resolutions_.length-2),o=this.resolutions_[e]/this.resolutions_[e+1];return this.resolutions_[e]/Math.pow(o,clamp(t-e,0,1))}return this.maxResolution_/Math.pow(this.zoomFactor_,t-this.minZoom_)}fit(t,e){let o;if(assert(Array.isArray(t)||"function"==typeof t.getSimplifiedGeometry,24),Array.isArray(t)){assert(!isEmpty(t),25);const e=fromUserExtent(t,this.getProjection());o=polygonFromExtent(e)}else if(t.getType()===GeometryType.CIRCLE){const e=fromUserExtent(t.getExtent(),this.getProjection());o=polygonFromExtent(e),o.rotate(this.getRotation(),getCenter(e))}else{const e=getUserProjection();o=e?t.clone().transform(e,this.getProjection()):t}this.fitInternal(o,e)}rotatedExtentForGeometry(t){const e=this.getRotation(),o=Math.cos(e),n=Math.sin(-e),i=t.getFlatCoordinates(),s=t.getStride();let r=1/0,a=1/0,h=-1/0,l=-1/0;for(let t=0,e=i.length;t<e;t+=s){const e=i[t]*o-i[t+1]*n,s=i[t]*n+i[t+1]*o;r=Math.min(r,e),a=Math.min(a,s),h=Math.max(h,e),l=Math.max(l,s)}return[r,a,h,l]}fitInternal(t,e){const o=e||{};let n=o.size;n||(n=this.getViewportSizeMinusPadding_());const i=void 0!==o.padding?o.padding:[0,0,0,0],s=void 0!==o.nearest&&o.nearest;let r;r=void 0!==o.minResolution?o.minResolution:void 0!==o.maxZoom?this.getResolutionForZoom(o.maxZoom):0;const a=this.rotatedExtentForGeometry(t);let h=this.getResolutionForExtentInternal(a,[n[0]-i[1]-i[3],n[1]-i[0]-i[2]]);h=isNaN(h)?r:Math.max(h,r),h=this.getConstrainedResolution(h,s?0:1);const l=this.getRotation(),c=Math.sin(l),u=Math.cos(l),g=getCenter(a);g[0]+=(i[1]-i[3])/2*h,g[1]+=(i[0]-i[2])/2*h;const m=g[0]*u-g[1]*c,d=g[1]*u+g[0]*c,_=this.getConstrainedCenter([m,d],h),R=o.callback?o.callback:VOID;void 0!==o.duration?this.animateInternal({resolution:h,center:_,duration:o.duration,easing:o.easing},R):(this.targetResolution_=h,this.targetCenter_=_,this.applyTargetState_(!1,!0),animationCallback(R,!0))}centerOn(t,e,o){this.centerOnInternal(fromUserCoordinate(t,this.getProjection()),e,o)}centerOnInternal(t,e,o){this.setCenterInternal(calculateCenterOn(t,e,o,this.getResolution(),this.getRotation()))}calculateCenterShift(t,e,o,n){let i;const s=this.padding_;if(s&&t){const r=this.getViewportSizeMinusPadding_(-o),a=calculateCenterOn(t,n,[r[0]/2+s[3],r[1]/2+s[0]],e,o);i=[t[0]-a[0],t[1]-a[1]]}return i}isDef(){return!!this.getCenterInternal()&&void 0!==this.getResolution()}adjustCenter(t){const e=toUserCoordinate(this.targetCenter_,this.getProjection());this.setCenter([e[0]+t[0],e[1]+t[1]])}adjustCenterInternal(t){const e=this.targetCenter_;this.setCenterInternal([e[0]+t[0],e[1]+t[1]])}adjustResolution(t,e){const o=e&&fromUserCoordinate(e,this.getProjection());this.adjustResolutionInternal(t,o)}adjustResolutionInternal(t,e){const o=this.getAnimating()||this.getInteracting(),n=this.getViewportSize_(this.getRotation()),i=this.constraints_.resolution(this.targetResolution_*t,0,n,o);e&&(this.targetCenter_=this.calculateCenterZoom(i,e)),this.targetResolution_*=t,this.applyTargetState_()}adjustZoom(t,e){this.adjustResolution(Math.pow(this.zoomFactor_,-t),e)}adjustRotation(t,e){e&&(e=fromUserCoordinate(e,this.getProjection())),this.adjustRotationInternal(t,e)}adjustRotationInternal(t,e){const o=this.getAnimating()||this.getInteracting(),n=this.constraints_.rotation(this.targetRotation_+t,o);e&&(this.targetCenter_=this.calculateCenterRotate(n,e)),this.targetRotation_+=t,this.applyTargetState_()}setCenter(t){this.setCenterInternal(fromUserCoordinate(t,this.getProjection()))}setCenterInternal(t){this.targetCenter_=t,this.applyTargetState_()}setHint(t,e){return this.hints_[t]+=e,this.changed(),this.hints_[t]}setResolution(t){this.targetResolution_=t,this.applyTargetState_()}setRotation(t){this.targetRotation_=t,this.applyTargetState_()}setZoom(t){this.setResolution(this.getResolutionForZoom(t))}applyTargetState_(t,e){const o=this.getAnimating()||this.getInteracting()||e,n=this.constraints_.rotation(this.targetRotation_,o),i=this.getViewportSize_(n),s=this.constraints_.resolution(this.targetResolution_,0,i,o),r=this.constraints_.center(this.targetCenter_,s,i,o,this.calculateCenterShift(this.targetCenter_,s,n,i));this.get(ViewProperty.ROTATION)!==n&&this.set(ViewProperty.ROTATION,n),this.get(ViewProperty.RESOLUTION)!==s&&(this.set(ViewProperty.RESOLUTION,s),this.set("zoom",this.getZoom(),!0)),r&&this.get(ViewProperty.CENTER)&&equals(this.get(ViewProperty.CENTER),r)||this.set(ViewProperty.CENTER,r),this.getAnimating()&&!t&&this.cancelAnimations(),this.cancelAnchor_=void 0}resolveConstraints(t,e,o){const n=void 0!==t?t:200,i=e||0,s=this.constraints_.rotation(this.targetRotation_),r=this.getViewportSize_(s),a=this.constraints_.resolution(this.targetResolution_,i,r),h=this.constraints_.center(this.targetCenter_,a,r,!1,this.calculateCenterShift(this.targetCenter_,a,s,r));if(0===n&&!this.cancelAnchor_)return this.targetResolution_=a,this.targetRotation_=s,this.targetCenter_=h,void this.applyTargetState_();const l=o||(0===n?this.cancelAnchor_:void 0);this.cancelAnchor_=void 0,this.getResolution()===a&&this.getRotation()===s&&this.getCenterInternal()&&equals(this.getCenterInternal(),h)||(this.getAnimating()&&this.cancelAnimations(),this.animateInternal({rotation:s,center:h,resolution:a,duration:n,easing:easeOut,anchor:l}))}beginInteraction(){this.resolveConstraints(0),this.setHint(ViewHint.INTERACTING,1)}endInteraction(t,e,o){const n=o&&fromUserCoordinate(o,this.getProjection());this.endInteractionInternal(t,e,n)}endInteractionInternal(t,e,o){this.setHint(ViewHint.INTERACTING,-1),this.resolveConstraints(t,e,o)}getConstrainedCenter(t,e){const o=this.getViewportSize_(this.getRotation());return this.constraints_.center(t,e||this.getResolution(),o)}getConstrainedZoom(t,e){const o=this.getResolutionForZoom(t);return this.getZoomForResolution(this.getConstrainedResolution(o,e))}getConstrainedResolution(t,e){const o=e||0,n=this.getViewportSize_(this.getRotation());return this.constraints_.resolution(t,o,n)}}function animationCallback(t,e){setTimeout((function(){t(e)}),0)}export function createCenterConstraint(t){if(void 0!==t.extent){const e=void 0===t.smoothExtentConstraint||t.smoothExtentConstraint;return createExtent(t.extent,t.constrainOnlyCenter,e)}const e=createProjection(t.projection,"EPSG:3857");if(!0!==t.multiWorld&&e.isGlobal()){const t=e.getExtent().slice();return t[0]=-1/0,t[2]=1/0,createExtent(t,!1,!1)}return centerNone}export function createResolutionConstraint(t){let e,o,n;let i=void 0!==t.minZoom?t.minZoom:0,s=void 0!==t.maxZoom?t.maxZoom:28;const r=void 0!==t.zoomFactor?t.zoomFactor:2,a=void 0!==t.multiWorld&&t.multiWorld,h=void 0===t.smoothResolutionConstraint||t.smoothResolutionConstraint,l=void 0!==t.showFullExtent&&t.showFullExtent,c=createProjection(t.projection,"EPSG:3857"),u=c.getExtent();let g=t.constrainOnlyCenter,m=t.extent;if(a||m||!c.isGlobal()||(g=!1,m=u),void 0!==t.resolutions){const r=t.resolutions;o=r[i],n=void 0!==r[s]?r[s]:r[r.length-1],e=t.constrainResolution?createSnapToResolutions(r,h,!g&&m,l):createMinMaxResolution(o,n,h,!g&&m,l)}else{const a=(u?Math.max(getWidth(u),getHeight(u)):360*METERS_PER_UNIT[Units.DEGREES]/c.getMetersPerUnit())/DEFAULT_TILE_SIZE/Math.pow(2,0),d=a/Math.pow(2,28);o=t.maxResolution,void 0!==o?i=0:o=a/Math.pow(r,i),n=t.minResolution,void 0===n&&(n=void 0!==t.maxZoom?void 0!==t.maxResolution?o/Math.pow(r,s):a/Math.pow(r,s):d),s=i+Math.floor(Math.log(o/n)/Math.log(r)),n=o/Math.pow(r,s-i),e=t.constrainResolution?createSnapToPower(r,o,n,h,!g&&m,l):createMinMaxResolution(o,n,h,!g&&m,l)}return{constraint:e,maxResolution:o,minResolution:n,minZoom:i,zoomFactor:r}}export function createRotationConstraint(t){if(void 0===t.enableRotation||t.enableRotation){const e=t.constrainRotation;return void 0===e||!0===e?createSnapToZero():!1===e?rotationNone:"number"==typeof e?createSnapToN(e):rotationNone}return disable}export function isNoopAnimation(t){return!(t.sourceCenter&&t.targetCenter&&!coordinatesEqual(t.sourceCenter,t.targetCenter))&&(t.sourceResolution===t.targetResolution&&t.sourceRotation===t.targetRotation)}function calculateCenterOn(t,e,o,n,i){const s=Math.cos(-i);let r=Math.sin(-i),a=t[0]*s-t[1]*r,h=t[1]*s+t[0]*r;a+=(e[0]/2-o[0])*n,h+=(o[1]-e[1]/2)*n,r=-r;return[a*s-h*r,h*s+a*r]}export default View;
//# sourceMappingURL=/sm/bcb8118c5ad287dcfc0aa004f9515c36519329d788bbe5f5a1173981301d433b.map