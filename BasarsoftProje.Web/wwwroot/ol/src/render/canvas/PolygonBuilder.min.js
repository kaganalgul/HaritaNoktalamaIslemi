/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/render/canvas/PolygonBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import CanvasBuilder from"./Builder.js";import CanvasInstruction,{beginPathInstruction,closePathInstruction,fillInstruction,strokeInstruction}from"./Instruction.js";import{defaultFillStyle}from"../canvas.js";import{snap}from"../../geom/flat/simplify.js";class CanvasPolygonBuilder extends CanvasBuilder{constructor(t,i,s,n){super(t,i,s,n)}drawFlatCoordinatess_(t,i,s,n){const e=this.state,o=void 0!==e.fillStyle,r=void 0!==e.strokeStyle,l=s.length;this.instructions.push(beginPathInstruction),this.hitDetectionInstructions.push(beginPathInstruction);for(let e=0;e<l;++e){const o=s[e],l=this.coordinates.length,h=this.appendFlatLineCoordinates(t,i,o,n,!0,!r),u=[CanvasInstruction.MOVE_TO_LINE_TO,l,h];this.instructions.push(u),this.hitDetectionInstructions.push(u),r&&(this.instructions.push(closePathInstruction),this.hitDetectionInstructions.push(closePathInstruction)),i=o}return o&&(this.instructions.push(fillInstruction),this.hitDetectionInstructions.push(fillInstruction)),r&&(this.instructions.push(strokeInstruction),this.hitDetectionInstructions.push(strokeInstruction)),i}drawCircle(t,i){const s=this.state,n=s.fillStyle,e=s.strokeStyle;if(void 0===n&&void 0===e)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),void 0!==s.fillStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE,defaultFillStyle]),void 0!==s.strokeStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE,s.strokeStyle,s.lineWidth,s.lineCap,s.lineJoin,s.miterLimit,s.lineDash,s.lineDashOffset]);const o=t.getFlatCoordinates(),r=t.getStride(),l=this.coordinates.length;this.appendFlatLineCoordinates(o,0,o.length,r,!1,!1);const h=[CanvasInstruction.CIRCLE,l];this.instructions.push(beginPathInstruction,h),this.hitDetectionInstructions.push(beginPathInstruction,h),void 0!==s.fillStyle&&(this.instructions.push(fillInstruction),this.hitDetectionInstructions.push(fillInstruction)),void 0!==s.strokeStyle&&(this.instructions.push(strokeInstruction),this.hitDetectionInstructions.push(strokeInstruction)),this.endGeometry(i)}drawPolygon(t,i){const s=this.state,n=s.fillStyle,e=s.strokeStyle;if(void 0===n&&void 0===e)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),void 0!==s.fillStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE,defaultFillStyle]),void 0!==s.strokeStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE,s.strokeStyle,s.lineWidth,s.lineCap,s.lineJoin,s.miterLimit,s.lineDash,s.lineDashOffset]);const o=t.getEnds(),r=t.getOrientedFlatCoordinates(),l=t.getStride();this.drawFlatCoordinatess_(r,0,o,l),this.endGeometry(i)}drawMultiPolygon(t,i){const s=this.state,n=s.fillStyle,e=s.strokeStyle;if(void 0===n&&void 0===e)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),void 0!==s.fillStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE,defaultFillStyle]),void 0!==s.strokeStyle&&this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE,s.strokeStyle,s.lineWidth,s.lineCap,s.lineJoin,s.miterLimit,s.lineDash,s.lineDashOffset]);const o=t.getEndss(),r=t.getOrientedFlatCoordinates(),l=t.getStride();let h=0;for(let t=0,i=o.length;t<i;++t)h=this.drawFlatCoordinatess_(r,h,o[t],l);this.endGeometry(i)}finish(){this.reverseHitDetectionInstructions(),this.state=null;const t=this.tolerance;if(0!==t){const i=this.coordinates;for(let s=0,n=i.length;s<n;++s)i[s]=snap(i[s],t)}return super.finish()}setFillStrokeStyles_(){const t=this.state;void 0!==t.fillStyle&&this.updateFillStyle(t,this.createFill),void 0!==t.strokeStyle&&this.updateStrokeStyle(t,this.applyStroke)}}export default CanvasPolygonBuilder;
//# sourceMappingURL=/sm/cffcd2e8c67bf0429759b3fad5474121f0e38dea6bd45696dbdab974f5687770.map