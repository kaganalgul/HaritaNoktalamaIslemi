/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/render/canvas/ExecutorGroup.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import BuilderType from"./BuilderType.js";import Executor from"./Executor.js";import{buffer,createEmpty,extendCoordinate}from"../../extent.js";import{compose as composeTransform,create as createTransform}from"../../transform.js";import{createCanvasContext2D}from"../../dom.js";import{isEmpty}from"../../obj.js";import{numberSafeCompareFunction}from"../../array.js";import{transform2D}from"../../geom/flat/transform.js";const ORDER=[BuilderType.POLYGON,BuilderType.CIRCLE,BuilderType.LINE_STRING,BuilderType.IMAGE,BuilderType.TEXT,BuilderType.DEFAULT];class ExecutorGroup{constructor(e,t,r,o,n,i){this.maxExtent_=e,this.overlaps_=o,this.pixelRatio_=r,this.resolution_=t,this.renderBuffer_=i,this.executorsByZIndex_={},this.hitDetectionContext_=null,this.hitDetectionTransform_=createTransform(),this.createExecutors_(n)}clip(e,t){const r=this.getClipCoords(t);e.beginPath(),e.moveTo(r[0],r[1]),e.lineTo(r[2],r[3]),e.lineTo(r[4],r[5]),e.lineTo(r[6],r[7]),e.clip()}createExecutors_(e){for(const t in e){let r=this.executorsByZIndex_[t];void 0===r&&(r={},this.executorsByZIndex_[t]=r);const o=e[t];for(const e in o){const t=o[e];r[e]=new Executor(this.resolution_,this.pixelRatio_,this.overlaps_,t)}}}hasExecutors(e){for(const t in this.executorsByZIndex_){const r=this.executorsByZIndex_[t];for(let t=0,o=e.length;t<o;++t)if(e[t]in r)return!0}return!1}forEachFeatureAtCoordinate(e,t,r,o,n,i){const s=2*(o=Math.round(o))+1,c=composeTransform(this.hitDetectionTransform_,o+.5,o+.5,1/t,-1/t,-r,-e[0],-e[1]),a=!this.hitDetectionContext_;a&&(this.hitDetectionContext_=createCanvasContext2D(s,s));const u=this.hitDetectionContext_;let x;u.canvas.width!==s||u.canvas.height!==s?(u.canvas.width=s,u.canvas.height=s):a||u.clearRect(0,0,s,s),void 0!==this.renderBuffer_&&(x=createEmpty(),extendCoordinate(x,e),buffer(x,t*(this.renderBuffer_+o),x));const h=getPixelIndexArray(o);let l;function f(e,t){const r=u.getImageData(0,0,s,s).data;for(let c=0,a=h.length;c<a;c++)if(r[h[c]]>0){if(!i||l!==BuilderType.IMAGE&&l!==BuilderType.TEXT||-1!==i.indexOf(e)){const r=(h[c]-3)/4,i=o-r%s,a=o-(r/s|0),u=n(e,t,i*i+a*a);if(u)return u}u.clearRect(0,0,s,s);break}}const m=Object.keys(this.executorsByZIndex_).map(Number);let p,d,y,_,E;for(m.sort(numberSafeCompareFunction),p=m.length-1;p>=0;--p){const e=m[p].toString();for(y=this.executorsByZIndex_[e],d=ORDER.length-1;d>=0;--d)if(l=ORDER[d],_=y[l],void 0!==_&&(E=_.executeHitDetection(u,c,r,f,x),E))return E}}getClipCoords(e){const t=this.maxExtent_;if(!t)return null;const r=t[0],o=t[1],n=t[2],i=t[3],s=[r,o,r,i,n,i,n,o];return transform2D(s,0,8,2,e,s),s}isEmpty(){return isEmpty(this.executorsByZIndex_)}execute(e,t,r,o,n,i,s){const c=Object.keys(this.executorsByZIndex_).map(Number);c.sort(numberSafeCompareFunction),this.maxExtent_&&(e.save(),this.clip(e,r));const a=i||ORDER;let u,x,h,l,f,m;for(s&&c.reverse(),u=0,x=c.length;u<x;++u){const i=c[u].toString();for(f=this.executorsByZIndex_[i],h=0,l=a.length;h<l;++h){m=f[a[h]],void 0!==m&&m.execute(e,t,r,o,n,s)}}this.maxExtent_&&e.restore()}}const circlePixelIndexArrayCache={};export function getPixelIndexArray(e){if(void 0!==circlePixelIndexArrayCache[e])return circlePixelIndexArrayCache[e];const t=2*e+1,r=e*e,o=new Array(r+1);for(let n=0;n<=e;++n)for(let i=0;i<=e;++i){const s=n*n+i*i;if(s>r)break;let c=o[s];c||(c=[],o[s]=c),c.push(4*((e+n)*t+(e+i))+3),n>0&&c.push(4*((e-n)*t+(e+i))+3),i>0&&(c.push(4*((e+n)*t+(e-i))+3),n>0&&c.push(4*((e-n)*t+(e-i))+3))}const n=[];for(let e=0,t=o.length;e<t;++e)o[e]&&n.push(...o[e]);return circlePixelIndexArrayCache[e]=n,n}export default ExecutorGroup;
//# sourceMappingURL=/sm/1821ccca415b0af311f94411f761fe294d388bb8b9a908d11a35cf25d9570a68.map