/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/format/MVT.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import FeatureFormat,{transformGeometryWithOptions}from"./Feature.js";import FormatType from"./FormatType.js";import GeometryLayout from"../geom/GeometryLayout.js";import GeometryType from"../geom/GeometryType.js";import LineString from"../geom/LineString.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import PBF from"pbf";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import Projection from"../proj/Projection.js";import RenderFeature from"../render/Feature.js";import Units from"../proj/Units.js";import{assert}from"../asserts.js";import{get}from"../proj.js";import{linearRingIsClockwise}from"../geom/flat/orient.js";class MVT extends FeatureFormat{constructor(e){super();const t=e||{};this.dataProjection=new Projection({code:"",units:Units.TILE_PIXELS}),this.featureClass_=t.featureClass?t.featureClass:RenderFeature,this.geometryName_=t.geometryName,this.layerName_=t.layerName?t.layerName:"layer",this.layers_=t.layers?t.layers:null,this.idProperty_=t.idProperty,this.supportedMediaTypes=["application/vnd.mapbox-vector-tile","application/x-protobuf"]}readRawGeometry_(e,t,r,o){e.pos=t.geometry;const a=e.readVarint()+e.pos;let s=1,n=0,i=0,l=0,y=0,m=0;for(;e.pos<a;){if(!n){const t=e.readVarint();s=7&t,n=t>>3}n--,1===s||2===s?(i+=e.readSVarint(),l+=e.readSVarint(),1===s&&y>m&&(o.push(y),m=y),r.push(i,l),y+=2):7===s?y>m&&(r.push(r[m],r[m+1]),y+=2):assert(!1,59)}y>m&&(o.push(y),m=y)}createFeature_(e,t,r){const o=t.type;if(0===o)return null;let a;const s=t.properties;let n;this.idProperty_?(n=s[this.idProperty_],delete s[this.idProperty_]):n=t.id,s[this.layerName_]=t.layer.name;const i=[],l=[];this.readRawGeometry_(e,t,i,l);const y=getGeometryType(o,l.length);if(this.featureClass_===RenderFeature)a=new this.featureClass_(y,i,l,s,n),a.transform(r.dataProjection);else{let e;if(y==GeometryType.POLYGON){const t=[];let r=0,o=0;for(let e=0,a=l.length;e<a;++e){const a=l[e];if(linearRingIsClockwise(i,r,a,2)){if(0===t.length)continue;t[t.length-1].push(l[o])}else t.push(l.slice(o,e+1));o=e+1,r=a}e=t.length>1?new MultiPolygon(i,GeometryLayout.XY,t):new Polygon(i,GeometryLayout.XY,l)}else e=y===GeometryType.POINT?new Point(i,GeometryLayout.XY):y===GeometryType.LINE_STRING?new LineString(i,GeometryLayout.XY):y===GeometryType.POLYGON?new Polygon(i,GeometryLayout.XY,l):y===GeometryType.MULTI_POINT?new MultiPoint(i,GeometryLayout.XY):y===GeometryType.MULTI_LINE_STRING?new MultiLineString(i,GeometryLayout.XY,l):null;a=new(0,this.featureClass_),this.geometryName_&&a.setGeometryName(this.geometryName_);const t=transformGeometryWithOptions(e,!1,r);a.setGeometry(t),a.setId(n),a.setProperties(s,!0)}return a}getType(){return FormatType.ARRAY_BUFFER}readFeatures(e,t){const r=this.layers_,o=this.adaptOptions(t),a=get(o.dataProjection);a.setWorldExtent(o.extent),o.dataProjection=a;const s=new PBF(e),n=s.readFields(layersPBFReader,{}),i=[];for(const e in n){if(r&&-1==r.indexOf(e))continue;const t=n[e],l=t?[0,0,t.extent,t.extent]:null;a.setExtent(l);for(let e=0,r=t.length;e<r;++e){const r=readRawFeature(s,t,e),a=this.createFeature_(s,r,o);null!==a&&i.push(a)}}return i}readProjection(e){return this.dataProjection}setLayers(e){this.layers_=e}}function layersPBFReader(e,t,r){if(3===e){const e={keys:[],values:[],features:[]},o=r.readVarint()+r.pos;r.readFields(layerPBFReader,e,o),e.length=e.features.length,e.length&&(t[e.name]=e)}}function layerPBFReader(e,t,r){if(15===e)t.version=r.readVarint();else if(1===e)t.name=r.readString();else if(5===e)t.extent=r.readVarint();else if(2===e)t.features.push(r.pos);else if(3===e)t.keys.push(r.readString());else if(4===e){let o=null;const a=r.readVarint()+r.pos;for(;r.pos<a;)o=1===(e=r.readVarint()>>3)?r.readString():2===e?r.readFloat():3===e?r.readDouble():4===e?r.readVarint64():5===e?r.readVarint():6===e?r.readSVarint():7===e?r.readBoolean():null;t.values.push(o)}}function featurePBFReader(e,t,r){if(1==e)t.id=r.readVarint();else if(2==e){const e=r.readVarint()+r.pos;for(;r.pos<e;){const e=t.layer.keys[r.readVarint()],o=t.layer.values[r.readVarint()];t.properties[e]=o}}else 3==e?t.type=r.readVarint():4==e&&(t.geometry=r.pos)}function readRawFeature(e,t,r){e.pos=t.features[r];const o=e.readVarint()+e.pos,a={layer:t,type:0,properties:{}};return e.readFields(featurePBFReader,a,o),a}function getGeometryType(e,t){let r;return 1===e?r=1===t?GeometryType.POINT:GeometryType.MULTI_POINT:2===e?r=1===t?GeometryType.LINE_STRING:GeometryType.MULTI_LINE_STRING:3===e&&(r=GeometryType.POLYGON),r}export default MVT;
//# sourceMappingURL=/sm/fd97e9e42028e9fb969bb44c80d9e2ded1bf51e3572f93f25529f1f40079f538.map