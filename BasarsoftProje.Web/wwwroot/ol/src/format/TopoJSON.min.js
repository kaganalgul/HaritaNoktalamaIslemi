/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/format/TopoJSON.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Feature from"../Feature.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{get as getProjection}from"../proj.js";import{transformGeometryWithOptions}from"./Feature.js";class TopoJSON extends JSONFeature{constructor(t){super();const e=t||{};this.layerName_=e.layerName,this.layers_=e.layers?e.layers:null,this.dataProjection=getProjection(e.dataProjection?e.dataProjection:"EPSG:4326")}readFeaturesFromObject(t,e){if("Topology"==t.type){const r=t;let o,n=null,i=null;r.transform&&(o=r.transform,n=o.scale,i=o.translate);const s=r.arcs;o&&transformArcs(s,n,i);const a=[],l=r.objects,c=this.layerName_;let m;for(const t in l)this.layers_&&-1==this.layers_.indexOf(t)||("GeometryCollection"===l[t].type?(m=l[t],a.push.apply(a,readFeaturesFromGeometryCollection(m,s,n,i,c,t,e))):(m=l[t],a.push(readFeatureFromGeometry(m,s,n,i,c,t,e))));return a}return[]}readProjectionFromObject(t){return this.dataProjection}}const GEOMETRY_READERS={Point:readPointGeometry,LineString:readLineStringGeometry,Polygon:readPolygonGeometry,MultiPoint:readMultiPointGeometry,MultiLineString:readMultiLineStringGeometry,MultiPolygon:readMultiPolygonGeometry};function concatenateArcs(t,e){const r=[];let o;for(let n=0,i=t.length;n<i;++n)if(o=t[n],n>0&&r.pop(),o>=0){const t=e[o];for(let e=0,o=t.length;e<o;++e)r.push(t[e].slice(0))}else{const t=e[~o];for(let e=t.length-1;e>=0;--e)r.push(t[e].slice(0))}return r}function readPointGeometry(t,e,r){const o=t.coordinates;return e&&r&&transformVertex(o,e,r),new Point(o)}function readMultiPointGeometry(t,e,r){const o=t.coordinates;if(e&&r)for(let t=0,n=o.length;t<n;++t)transformVertex(o[t],e,r);return new MultiPoint(o)}function readLineStringGeometry(t,e){const r=concatenateArcs(t.arcs,e);return new LineString(r)}function readMultiLineStringGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o)r[o]=concatenateArcs(t.arcs[o],e);return new MultiLineString(r)}function readPolygonGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o)r[o]=concatenateArcs(t.arcs[o],e);return new Polygon(r)}function readMultiPolygonGeometry(t,e){const r=[];for(let o=0,n=t.arcs.length;o<n;++o){const n=t.arcs[o],i=[];for(let t=0,r=n.length;t<r;++t)i[t]=concatenateArcs(n[t],e);r[o]=i}return new MultiPolygon(r)}function readFeaturesFromGeometryCollection(t,e,r,o,n,i,s){const a=t.geometries,l=[];for(let t=0,c=a.length;t<c;++t)l[t]=readFeatureFromGeometry(a[t],e,r,o,n,i,s);return l}function readFeatureFromGeometry(t,e,r,o,n,i,s){let a=null;const l=t.type;if(l){const n=GEOMETRY_READERS[l];a="Point"===l||"MultiPoint"===l?n(t,r,o):n(t,e),a=transformGeometryWithOptions(a,!1,s)}const c=new Feature({geometry:a});void 0!==t.id&&c.setId(t.id);let m=t.properties;return n&&(m||(m={}),m[n]=i),m&&c.setProperties(m,!0),c}function transformArcs(t,e,r){for(let o=0,n=t.length;o<n;++o)transformArc(t[o],e,r)}function transformArc(t,e,r){let o=0,n=0;for(let i=0,s=t.length;i<s;++i){const s=t[i];o+=s[0],n+=s[1],s[0]=o,s[1]=n,transformVertex(s,e,r)}}function transformVertex(t,e,r){t[0]=t[0]*e[0]+r[0],t[1]=t[1]*e[1]+r[1]}export default TopoJSON;
//# sourceMappingURL=/sm/0fe3fb1b9025cf52f724357918833b9702713a2b2787c36c4d977558cd7c3444.map