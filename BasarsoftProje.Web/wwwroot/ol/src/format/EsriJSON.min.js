/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/format/EsriJSON.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Feature from"../Feature.js";import GeometryLayout from"../geom/GeometryLayout.js";import GeometryType from"../geom/GeometryType.js";import JSONFeature from"./JSONFeature.js";import LineString from"../geom/LineString.js";import LinearRing from"../geom/LinearRing.js";import MultiLineString from"../geom/MultiLineString.js";import MultiPoint from"../geom/MultiPoint.js";import MultiPolygon from"../geom/MultiPolygon.js";import Point from"../geom/Point.js";import Polygon from"../geom/Polygon.js";import{assert}from"../asserts.js";import{assign,isEmpty}from"../obj.js";import{containsExtent}from"../extent.js";import{deflateCoordinates}from"../geom/flat/deflate.js";import{get as getProjection}from"../proj.js";import{linearRingIsClockwise}from"../geom/flat/orient.js";import{transformGeometryWithOptions}from"./Feature.js";const GEOMETRY_READERS={};GEOMETRY_READERS[GeometryType.POINT]=readPointGeometry,GEOMETRY_READERS[GeometryType.LINE_STRING]=readLineStringGeometry,GEOMETRY_READERS[GeometryType.POLYGON]=readPolygonGeometry,GEOMETRY_READERS[GeometryType.MULTI_POINT]=readMultiPointGeometry,GEOMETRY_READERS[GeometryType.MULTI_LINE_STRING]=readMultiLineStringGeometry,GEOMETRY_READERS[GeometryType.MULTI_POLYGON]=readMultiPolygonGeometry;const GEOMETRY_WRITERS={};GEOMETRY_WRITERS[GeometryType.POINT]=writePointGeometry,GEOMETRY_WRITERS[GeometryType.LINE_STRING]=writeLineStringGeometry,GEOMETRY_WRITERS[GeometryType.POLYGON]=writePolygonGeometry,GEOMETRY_WRITERS[GeometryType.MULTI_POINT]=writeMultiPointGeometry,GEOMETRY_WRITERS[GeometryType.MULTI_LINE_STRING]=writeMultiLineStringGeometry,GEOMETRY_WRITERS[GeometryType.MULTI_POLYGON]=writeMultiPolygonGeometry;class EsriJSON extends JSONFeature{constructor(e){const t=e||{};super(),this.geometryName_=t.geometryName}readFeatureFromObject(e,t,r){const o=e,n=readGeometry(o.geometry,t),i=new Feature;if(this.geometryName_&&i.setGeometryName(this.geometryName_),i.setGeometry(n),o.attributes){i.setProperties(o.attributes,!0);const e=o.attributes[r];void 0!==e&&i.setId(e)}return i}readFeaturesFromObject(e,t){const r=t||{};if(e.features){const t=[],o=e.features;for(let n=0,i=o.length;n<i;++n)t.push(this.readFeatureFromObject(o[n],r,e.objectIdFieldName));return t}return[this.readFeatureFromObject(e,r)]}readGeometryFromObject(e,t){return readGeometry(e,t)}readProjectionFromObject(e){if(e.spatialReference&&void 0!==e.spatialReference.wkid){const t=e.spatialReference.wkid;return getProjection("EPSG:"+t)}return null}writeGeometryObject(e,t){return writeGeometry(e,this.adaptOptions(t))}writeFeatureObject(e,t){t=this.adaptOptions(t);const r={};if(!e.hasProperties())return r.attributes={},r;const o=e.getProperties(),n=e.getGeometry();if(n){r.geometry=writeGeometry(n,t);const i=t&&(t.dataProjection||t.featureProjection);i&&(r.geometry.spatialReference={wkid:Number(getProjection(i).getCode().split(":").pop())}),delete o[e.getGeometryName()]}return isEmpty(o)?r.attributes={}:r.attributes=o,r}writeFeaturesObject(e,t){t=this.adaptOptions(t);const r=[];for(let o=0,n=e.length;o<n;++o)r.push(this.writeFeatureObject(e[o],t));return{features:r}}}function readGeometry(e,t){if(!e)return null;let r;if("number"==typeof e.x&&"number"==typeof e.y)r=GeometryType.POINT;else if(e.points)r=GeometryType.MULTI_POINT;else if(e.paths){r=1===e.paths.length?GeometryType.LINE_STRING:GeometryType.MULTI_LINE_STRING}else if(e.rings){const t=e,o=getGeometryLayout(t),n=convertRings(t.rings,o);1===n.length?(r=GeometryType.POLYGON,e=assign({},e,{rings:n[0]})):(r=GeometryType.MULTI_POLYGON,e=assign({},e,{rings:n}))}const o=GEOMETRY_READERS[r];return transformGeometryWithOptions(o(e),!1,t)}function convertRings(e,t){const r=[],o=[],n=[];let i,s;for(i=0,s=e.length;i<s;++i){r.length=0,deflateCoordinates(r,0,e[i],t.length);linearRingIsClockwise(r,0,r.length,t.length)?o.push([e[i]]):n.push(e[i])}for(;n.length;){const e=n.shift();let t=!1;for(i=o.length-1;i>=0;i--){const r=o[i][0];if(containsExtent(new LinearRing(r).getExtent(),new LinearRing(e).getExtent())){o[i].push(e),t=!0;break}}t||o.push([e.reverse()])}return o}function readPointGeometry(e){let t;return t=void 0!==e.m&&void 0!==e.z?new Point([e.x,e.y,e.z,e.m],GeometryLayout.XYZM):void 0!==e.z?new Point([e.x,e.y,e.z],GeometryLayout.XYZ):void 0!==e.m?new Point([e.x,e.y,e.m],GeometryLayout.XYM):new Point([e.x,e.y]),t}function readLineStringGeometry(e){const t=getGeometryLayout(e);return new LineString(e.paths[0],t)}function readMultiLineStringGeometry(e){const t=getGeometryLayout(e);return new MultiLineString(e.paths,t)}function getGeometryLayout(e){let t=GeometryLayout.XY;return!0===e.hasZ&&!0===e.hasM?t=GeometryLayout.XYZM:!0===e.hasZ?t=GeometryLayout.XYZ:!0===e.hasM&&(t=GeometryLayout.XYM),t}function readMultiPointGeometry(e){const t=getGeometryLayout(e);return new MultiPoint(e.points,t)}function readMultiPolygonGeometry(e){const t=getGeometryLayout(e);return new MultiPolygon(e.rings,t)}function readPolygonGeometry(e){const t=getGeometryLayout(e);return new Polygon(e.rings,t)}function writePointGeometry(e,t){const r=e.getCoordinates();let o;const n=e.getLayout();return n===GeometryLayout.XYZ?o={x:r[0],y:r[1],z:r[2]}:n===GeometryLayout.XYM?o={x:r[0],y:r[1],m:r[2]}:n===GeometryLayout.XYZM?o={x:r[0],y:r[1],z:r[2],m:r[3]}:n===GeometryLayout.XY?o={x:r[0],y:r[1]}:assert(!1,34),o}function getHasZM(e){const t=e.getLayout();return{hasZ:t===GeometryLayout.XYZ||t===GeometryLayout.XYZM,hasM:t===GeometryLayout.XYM||t===GeometryLayout.XYZM}}function writeLineStringGeometry(e,t){const r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,paths:[e.getCoordinates()]}}function writePolygonGeometry(e,t){const r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,rings:e.getCoordinates(!1)}}function writeMultiLineStringGeometry(e,t){const r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,paths:e.getCoordinates()}}function writeMultiPointGeometry(e,t){const r=getHasZM(e);return{hasZ:r.hasZ,hasM:r.hasM,points:e.getCoordinates()}}function writeMultiPolygonGeometry(e,t){const r=getHasZM(e),o=e.getCoordinates(!1),n=[];for(let e=0;e<o.length;e++)for(let t=o[e].length-1;t>=0;t--)n.push(o[e][t]);return{hasZ:r.hasZ,hasM:r.hasM,rings:n}}function writeGeometry(e,t){return(0,GEOMETRY_WRITERS[e.getType()])(transformGeometryWithOptions(e,!0,t),t)}export default EsriJSON;
//# sourceMappingURL=/sm/a5ff389044e82e4d1fc2b2236bf2f6c56d4ffebbedfa1d0e567b8649a73f9b29.map