/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/geom/Circle.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import GeometryType from"./GeometryType.js";import SimpleGeometry from"./SimpleGeometry.js";import{createOrUpdate,forEachCorner,intersects}from"../extent.js";import{deflateCoordinate}from"./flat/deflate.js";import{rotate,translate}from"./flat/transform.js";class Circle extends SimpleGeometry{constructor(t,e,s){if(super(),void 0!==s&&void 0===e)this.setFlatCoordinates(s,t);else{const r=e||0;this.setCenterAndRadius(t,r,s)}}clone(){const t=new Circle(this.flatCoordinates.slice(),void 0,this.layout);return t.applyProperties(this),t}closestPointXY(t,e,s,r){const i=this.flatCoordinates,o=t-i[0],n=e-i[1],a=o*o+n*n;if(a<r){if(0===a)for(let t=0;t<this.stride;++t)s[t]=i[t];else{const t=this.getRadius()/Math.sqrt(a);s[0]=i[0]+t*o,s[1]=i[1]+t*n;for(let t=2;t<this.stride;++t)s[t]=i[t]}return s.length=this.stride,a}return r}containsXY(t,e){const s=this.flatCoordinates,r=t-s[0],i=e-s[1];return r*r+i*i<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(t){const e=this.flatCoordinates,s=e[this.stride]-e[0];return createOrUpdate(e[0]-s,e[1]-s,e[0]+s,e[1]+s,t)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e}getType(){return GeometryType.CIRCLE}intersectsExtent(t){const e=this.getExtent();if(intersects(t,e)){const e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||(t[1]<=e[1]&&t[3]>=e[1]||forEachCorner(t,this.intersectsCoordinate.bind(this)))}return!1}setCenter(t){const e=this.stride,s=this.flatCoordinates[e]-this.flatCoordinates[0],r=t.slice();r[e]=r[0]+s;for(let s=1;s<e;++s)r[e+s]=t[s];this.setFlatCoordinates(this.layout,r),this.changed()}setCenterAndRadius(t,e,s){this.setLayout(s,t,0),this.flatCoordinates||(this.flatCoordinates=[]);const r=this.flatCoordinates;let i=deflateCoordinate(r,0,t,this.stride);r[i++]=r[0]+e;for(let t=1,e=this.stride;t<e;++t)r[i++]=r[t];r.length=i,this.changed()}getCoordinates(){return null}setCoordinates(t,e){}setRadius(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()}rotate(t,e){const s=this.getCenter(),r=this.getStride();this.setCenter(rotate(s,0,s.length,r,t,e,s)),this.changed()}translate(t,e){const s=this.getCenter(),r=this.getStride();this.setCenter(translate(s,0,s.length,r,t,e,s)),this.changed()}}Circle.prototype.transform;export default Circle;
//# sourceMappingURL=/sm/1ec5ba446b544758aefc74a039770ec427c6647234fd54171ea90b61f29ce2e1.map