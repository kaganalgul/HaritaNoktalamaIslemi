/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/geom/GeometryCollection.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import EventType from"../events/EventType.js";import Geometry from"./Geometry.js";import GeometryType from"./GeometryType.js";import{closestSquaredDistanceXY,createOrUpdateEmpty,extend,getCenter}from"../extent.js";import{listen,unlistenByKey}from"../events.js";class GeometryCollection extends Geometry{constructor(e){super(),this.geometries_=e||null,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(unlistenByKey),this.changeEventsKeys_.length=0}listenGeometriesChange_(){if(this.geometries_)for(let e=0,t=this.geometries_.length;e<t;++e)this.changeEventsKeys_.push(listen(this.geometries_[e],EventType.CHANGE,this.changed,this))}clone(){const e=new GeometryCollection(null);return e.setGeometries(this.geometries_),e.applyProperties(this),e}closestPointXY(e,t,s,i){if(i<closestSquaredDistanceXY(this.getExtent(),e,t))return i;const r=this.geometries_;for(let n=0,o=r.length;n<o;++n)i=r[n].closestPointXY(e,t,s,i);return i}containsXY(e,t){const s=this.geometries_;for(let i=0,r=s.length;i<r;++i)if(s[i].containsXY(e,t))return!0;return!1}computeExtent(e){createOrUpdateEmpty(e);const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)extend(e,t[s].getExtent());return e}getGeometries(){return cloneGeometries(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let e=[];const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].getType()===this.getType()?e=e.concat(t[s].getGeometriesArrayRecursive()):e.push(t[s]);return e}getSimplifiedGeometry(e){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),e<0||0!==this.simplifiedGeometryMaxMinSquaredTolerance&&e<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const t=[],s=this.geometries_;let i=!1;for(let r=0,n=s.length;r<n;++r){const n=s[r],o=n.getSimplifiedGeometry(e);t.push(o),o!==n&&(i=!0)}if(i){const e=new GeometryCollection(null);return e.setGeometriesArray(t),e}return this.simplifiedGeometryMaxMinSquaredTolerance=e,this}getType(){return GeometryType.GEOMETRY_COLLECTION}intersectsExtent(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)if(t[s].intersectsExtent(e))return!0;return!1}isEmpty(){return 0===this.geometries_.length}rotate(e,t){const s=this.geometries_;for(let i=0,r=s.length;i<r;++i)s[i].rotate(e,t);this.changed()}scale(e,t,s){let i=s;i||(i=getCenter(this.getExtent()));const r=this.geometries_;for(let s=0,n=r.length;s<n;++s)r[s].scale(e,t,i);this.changed()}setGeometries(e){this.setGeometriesArray(cloneGeometries(e))}setGeometriesArray(e){this.unlistenGeometriesChange_(),this.geometries_=e,this.listenGeometriesChange_(),this.changed()}applyTransform(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].applyTransform(e);this.changed()}translate(e,t){const s=this.geometries_;for(let i=0,r=s.length;i<r;++i)s[i].translate(e,t);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function cloneGeometries(e){const t=[];for(let s=0,i=e.length;s<i;++s)t.push(e[s].clone());return t}export default GeometryCollection;
//# sourceMappingURL=/sm/e2eeef64041209a0b11a23d1d5f2e0e4584b57a7c23dc9822fd9ff9c7e147a0c.map