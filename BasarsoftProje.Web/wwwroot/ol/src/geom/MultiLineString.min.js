/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/geom/MultiLineString.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import GeometryLayout from"./GeometryLayout.js";import GeometryType from"./GeometryType.js";import LineString from"./LineString.js";import SimpleGeometry from"./SimpleGeometry.js";import{arrayMaxSquaredDelta,assignClosestArrayPoint}from"./flat/closest.js";import{closestSquaredDistanceXY}from"../extent.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{douglasPeuckerArray}from"./flat/simplify.js";import{extend}from"../array.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{interpolatePoint,lineStringsCoordinateAtM}from"./flat/interpolate.js";import{intersectsLineStringArray}from"./flat/intersectsextent.js";class MultiLineString extends SimpleGeometry{constructor(t,e,s){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(void 0!==e&&s)this.setFlatCoordinates(e,t),this.ends_=s;else{let e=this.getLayout();const s=t,i=[],r=[];for(let t=0,n=s.length;t<n;++t){const n=s[t];0===t&&(e=n.getLayout()),extend(i,n.getFlatCoordinates()),r.push(i.length)}this.setFlatCoordinates(e,i),this.ends_=r}}appendLineString(t){this.flatCoordinates?extend(this.flatCoordinates,t.getFlatCoordinates().slice()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new MultiLineString(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,s,i){return i<closestSquaredDistanceXY(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,s,i))}getCoordinateAtM(t,e,s){if(this.layout!=GeometryLayout.XYM&&this.layout!=GeometryLayout.XYZM||0===this.flatCoordinates.length)return null;const i=void 0!==e&&e,r=void 0!==s&&s;return lineStringsCoordinateAtM(this.flatCoordinates,0,this.ends_,this.stride,t,i,r)}getCoordinates(){return inflateCoordinatesArray(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new LineString(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const t=this.flatCoordinates,e=this.ends_,s=this.layout,i=[];let r=0;for(let n=0,o=e.length;n<o;++n){const o=e[n],a=new LineString(t.slice(r,o),s);i.push(a),r=o}return i}getFlatMidpoints(){const t=[],e=this.flatCoordinates;let s=0;const i=this.ends_,r=this.stride;for(let n=0,o=i.length;n<o;++n){const o=i[n],a=interpolatePoint(e,s,o,r,.5);extend(t,a),s=o}return t}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=douglasPeuckerArray(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,s),new MultiLineString(e,GeometryLayout.XY,s)}getType(){return GeometryType.MULTI_LINE_STRING}intersectsExtent(t){return intersectsLineStringArray(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const s=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===s.length?0:s[s.length-1],this.changed()}}export default MultiLineString;
//# sourceMappingURL=/sm/66d717c84cab5f63554b9d3a6140b0c41bf6114ec0ba3ef5630d651206ca2700.map