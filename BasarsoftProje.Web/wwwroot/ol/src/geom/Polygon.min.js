/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/geom/Polygon.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import GeometryLayout from"./GeometryLayout.js";import GeometryType from"./GeometryType.js";import LinearRing from"./LinearRing.js";import Point from"./Point.js";import SimpleGeometry from"./SimpleGeometry.js";import{arrayMaxSquaredDelta,assignClosestArrayPoint}from"./flat/closest.js";import{closestSquaredDistanceXY,getCenter}from"../extent.js";import{deflateCoordinatesArray}from"./flat/deflate.js";import{extend}from"../array.js";import{getInteriorPointOfArray}from"./flat/interiorpoint.js";import{inflateCoordinatesArray}from"./flat/inflate.js";import{intersectsLinearRingArray}from"./flat/intersectsextent.js";import{linearRingsAreOriented,orientLinearRings}from"./flat/orient.js";import{linearRings as linearRingsArea}from"./flat/area.js";import{linearRingsContainsXY}from"./flat/contains.js";import{modulo}from"../math.js";import{quantizeArray}from"./flat/simplify.js";import{offset as sphereOffset}from"../sphere.js";class Polygon extends SimpleGeometry{constructor(t,e,i){super(),this.ends_=[],this.flatInteriorPointRevision_=-1,this.flatInteriorPoint_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,void 0!==e&&i?(this.setFlatCoordinates(e,t),this.ends_=i):this.setCoordinates(t,e)}appendLinearRing(t){this.flatCoordinates?extend(this.flatCoordinates,t.getFlatCoordinates()):this.flatCoordinates=t.getFlatCoordinates().slice(),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new Polygon(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,i,s){return s<closestSquaredDistanceXY(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),assignClosestArrayPoint(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!0,t,e,i,s))}containsXY(t,e){return linearRingsContainsXY(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,e)}getArea(){return linearRingsArea(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride)}getCoordinates(t){let e;return void 0!==t?(e=this.getOrientedFlatCoordinates().slice(),orientLinearRings(e,0,this.ends_,this.stride,t)):e=this.flatCoordinates,inflateCoordinatesArray(e,0,this.ends_,this.stride)}getEnds(){return this.ends_}getFlatInteriorPoint(){if(this.flatInteriorPointRevision_!=this.getRevision()){const t=getCenter(this.getExtent());this.flatInteriorPoint_=getInteriorPointOfArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t,0),this.flatInteriorPointRevision_=this.getRevision()}return this.flatInteriorPoint_}getInteriorPoint(){return new Point(this.getFlatInteriorPoint(),GeometryLayout.XYM)}getLinearRingCount(){return this.ends_.length}getLinearRing(t){return t<0||this.ends_.length<=t?null:new LinearRing(this.flatCoordinates.slice(0===t?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLinearRings(){const t=this.layout,e=this.flatCoordinates,i=this.ends_,s=[];let n=0;for(let r=0,o=i.length;r<o;++r){const o=i[r],a=new LinearRing(e.slice(n,o),t);s.push(a),n=o}return s}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;linearRingsAreOriented(t,0,this.ends_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=orientLinearRings(this.orientedFlatCoordinates_,0,this.ends_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],i=[];return e.length=quantizeArray(this.flatCoordinates,0,this.ends_,this.stride,Math.sqrt(t),e,0,i),new Polygon(e,GeometryLayout.XY,i)}getType(){return GeometryType.POLYGON}intersectsExtent(t){return intersectsLinearRingArray(this.getOrientedFlatCoordinates(),0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const i=deflateCoordinatesArray(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=0===i.length?0:i[i.length-1],this.changed()}}export default Polygon;export function circular(t,e,i,s){const n=i||32,r=[];for(let i=0;i<n;++i)extend(r,sphereOffset(t,e,2*Math.PI*i/n,s));return r.push(r[0],r[1]),new Polygon(r,GeometryLayout.XY,[r.length])}export function fromExtent(t){const e=t[0],i=t[1],s=t[2],n=t[3],r=[e,i,e,n,s,n,s,i,e,i];return new Polygon(r,GeometryLayout.XY,[r.length])}export function fromCircle(t,e,i){const s=e||32,n=t.getStride(),r=t.getLayout(),o=t.getCenter(),a=n*(s+1),l=new Array(a);for(let t=0;t<a;t+=n){l[t]=0,l[t+1]=0;for(let e=2;e<n;e++)l[t+e]=o[e]}const h=[l.length],d=new Polygon(l,r,h);return makeRegular(d,o,t.getRadius(),i),d}export function makeRegular(t,e,i,s){const n=t.getFlatCoordinates(),r=t.getStride(),o=n.length/r-1,a=s||0;for(let t=0;t<=o;++t){const s=t*r,l=a+2*modulo(t,o)*Math.PI/o;n[s]=e[0]+i*Math.cos(l),n[s+1]=e[1]+i*Math.sin(l)}t.changed()}
//# sourceMappingURL=/sm/42780e7c21d7111fd502a22c15443d65f9c672139c1faa43efeb804c7e37755a.map