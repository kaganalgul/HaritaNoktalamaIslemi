/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/webgl/ShaderBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ValueTypes,expressionToGlsl,getStringNumberEquivalent,uniformNameForVariable}from"../style/expressions.js";export class ShaderBuilder{constructor(){this.uniforms=[],this.attributes=[],this.varyings=[],this.sizeExpression="vec2(1.0)",this.rotationExpression="0.0",this.offsetExpression="vec2(0.0)",this.colorExpression="vec4(1.0)",this.texCoordExpression="vec4(0.0, 0.0, 1.0, 1.0)",this.discardExpression="false",this.rotateWithView=!1}addUniform(e){return this.uniforms.push(e),this}addAttribute(e){return this.attributes.push(e),this}addVarying(e,t,o){return this.varyings.push({name:e,type:t,expression:o}),this}setSizeExpression(e){return this.sizeExpression=e,this}setRotationExpression(e){return this.rotationExpression=e,this}setSymbolOffsetExpression(e){return this.offsetExpression=e,this}setColorExpression(e){return this.colorExpression=e,this}setTextureCoordinateExpression(e){return this.texCoordExpression=e,this}setFragmentDiscardExpression(e){return this.discardExpression=e,this}setSymbolRotateWithView(e){return this.rotateWithView=e,this}getSizeExpression(){return this.sizeExpression}getOffsetExpression(){return this.offsetExpression}getColorExpression(){return this.colorExpression}getTextureCoordinateExpression(){return this.texCoordExpression}getFragmentDiscardExpression(){return this.discardExpression}getSymbolVertexShader(e){const t=this.rotateWithView?"u_offsetScaleMatrix * u_offsetRotateMatrix":"u_offsetScaleMatrix";let o=this.attributes,s=this.varyings;return e&&(o=o.concat("vec4 a_hitColor"),s=s.concat({name:"v_hitColor",type:"vec4",expression:"a_hitColor"})),`precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map((function(e){return"uniform "+e+";"})).join("\n")}\nattribute vec2 a_position;\nattribute float a_index;\n${o.map((function(e){return"attribute "+e+";"})).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${s.map((function(e){return"varying "+e.type+" "+e.name+";"})).join("\n")}\nvoid main(void) {\n  mat4 offsetMatrix = ${t};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${s.map((function(e){return"  "+e.name+" = "+e.expression+";"})).join("\n")}\n}`}getSymbolFragmentShader(e){const t=e?"  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;":"";let o=this.varyings;return e&&(o=o.concat({name:"v_hitColor",type:"vec4",expression:"a_hitColor"})),`precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map((function(e){return"uniform "+e+";"})).join("\n")}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${o.map((function(e){return"varying "+e.type+" "+e.name+";"})).join("\n")}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${t}\n}`}}export function parseLiteralStyle(e){const t=e.symbol,o=void 0!==t.size?t.size:1,s=t.color||"white",i=t.textureCoord||[0,0,1,1],r=t.offset||[0,0],n=void 0!==t.opacity?t.opacity:1,a=void 0!==t.rotation?t.rotation:0,f={inFragmentShader:!1,variables:[],attributes:[],stringLiteralsMap:{},functions:{}},l=expressionToGlsl(f,o,ValueTypes.NUMBER_ARRAY|ValueTypes.NUMBER),u=expressionToGlsl(f,r,ValueTypes.NUMBER_ARRAY),x=expressionToGlsl(f,i,ValueTypes.NUMBER_ARRAY),p=expressionToGlsl(f,a,ValueTypes.NUMBER),c={inFragmentShader:!0,variables:f.variables,attributes:[],stringLiteralsMap:f.stringLiteralsMap,functions:{}},h=expressionToGlsl(c,s,ValueTypes.COLOR),d=expressionToGlsl(c,n,ValueTypes.NUMBER);let m="1.0";const g=`vec2(${expressionToGlsl(c,o,ValueTypes.NUMBER_ARRAY|ValueTypes.NUMBER)}).x`;switch(t.symbolType){case"square":case"image":break;case"circle":m=`(1.0-smoothstep(1.-4./${g},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;break;case"triangle":const e="(v_quadCoord*2.-1.)",o=`(atan(${e}.x,${e}.y))`;m=`(1.0-smoothstep(.5-3./${g},.5,cos(floor(.5+${o}/2.094395102)*2.094395102-${o})*length(${e})))`;break;default:throw new Error("Unexpected symbol type: "+t.symbolType)}const v=(new ShaderBuilder).setSizeExpression(`vec2(${l})`).setRotationExpression(p).setSymbolOffsetExpression(u).setTextureCoordinateExpression(x).setSymbolRotateWithView(!!t.rotateWithView).setColorExpression(`vec4(${h}.rgb, ${h}.a * ${d} * ${m})`);if(e.filter){const t=expressionToGlsl(c,e.filter,ValueTypes.BOOLEAN);v.setFragmentDiscardExpression(`!${t}`)}const y={};if(c.variables.forEach((function(t){const o=uniformNameForVariable(t);v.addUniform(`float ${o}`),y[o]=function(){if(!e.variables||void 0===e.variables[t])throw new Error(`The following variable is missing from the style: ${t}`);let o=e.variables[t];return"string"==typeof o&&(o=getStringNumberEquivalent(f,o)),void 0!==o?o:-9999999}})),"image"===t.symbolType&&t.src){const e=new Image;e.src=t.src,v.addUniform("sampler2D u_texture").setColorExpression(v.getColorExpression()+" * texture2D(u_texture, v_texCoord)"),y.u_texture=e}return c.attributes.forEach((function(e){-1===f.attributes.indexOf(e)&&f.attributes.push(e),v.addVarying(`v_${e}`,"float",`a_${e}`)})),f.attributes.forEach((function(e){v.addAttribute(`float a_${e}`)})),{builder:v,attributes:f.attributes.map((function(e){return{name:e,callback:function(t,o){let s=o[e];return"string"==typeof s&&(s=getStringNumberEquivalent(f,s)),void 0!==s?s:-9999999}}})),uniforms:y}}
//# sourceMappingURL=/sm/70a4bc6f23d5e266a0f0abc79482844574813d5d625efc33a8ad68e683b89123.map