/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/webgl/TileTexture.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import EventTarget from"../events/Target.js";import EventType from"../events/EventType.js";import ImageTile from"../ImageTile.js";import ReprojTile from"../reproj/Tile.js";import TileState from"../TileState.js";import WebGLArrayBuffer from"./Buffer.js";import{ARRAY_BUFFER,STATIC_DRAW}from"../webgl.js";import{toSize}from"../size.js";function bindAndConfigure(e,t,i){const s=i?e.LINEAR:e.NEAREST;e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,s)}function uploadImageTexture(e,t,i,s){bindAndConfigure(e,t,s),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,i)}function uploadDataTexture(e,t,i,s,r,n){const a=e.getGL();bindAndConfigure(a,t,n);const o=i.byteLength/s[1];let l,h,T=1;switch(o%8==0?T=8:o%4==0?T=4:o%2==0&&(T=2),r){case 1:l=a.LUMINANCE;break;case 2:l=a.LUMINANCE_ALPHA;break;case 3:l=a.RGB;break;case 4:l=a.RGBA;break;default:throw new Error(`Unsupported number of bands: ${r}`)}i instanceof Float32Array?(h=a.FLOAT,e.getExtension("OES_texture_float"),e.getExtension("OES_texture_float_linear")):h=a.UNSIGNED_BYTE;const E=a.getParameter(a.UNPACK_ALIGNMENT);a.pixelStorei(a.UNPACK_ALIGNMENT,T),a.texImage2D(a.TEXTURE_2D,0,l,s[0],s[1],0,l,h,i),a.pixelStorei(a.UNPACK_ALIGNMENT,E)}class TileTexture extends EventTarget{constructor(e,t,i){super(),this.tile,this.textures=[],this.handleTileChange_=this.handleTileChange_.bind(this),this.size=toSize(t.getTileSize(e.tileCoord[0])),this.bandCount=NaN,this.helper_=i;const s=new WebGLArrayBuffer(ARRAY_BUFFER,STATIC_DRAW);s.fromArray([0,1,1,1,1,0,0,0]),i.flushBufferData(s),this.coords=s,this.setTile(e)}setTile(e){if(e!==this.tile)if(this.tile&&this.tile.removeEventListener(EventType.CHANGE,this.handleTileChange_),this.tile=e,this.textures.length=0,this.loaded=e.getState()===TileState.LOADED,this.loaded)this.uploadTile_();else{if(e instanceof ImageTile){const t=e.getImage();t instanceof Image&&!t.crossOrigin&&(t.crossOrigin="anonymous")}e.addEventListener(EventType.CHANGE,this.handleTileChange_)}}uploadTile_(){const e=this.helper_,t=e.getGL(),i=this.tile;if(i instanceof ImageTile||i instanceof ReprojTile){const e=t.createTexture();return this.textures.push(e),this.bandCount=4,void uploadImageTexture(t,e,i.getImage(),i.interpolate)}const s=i.getData(),r=s instanceof Float32Array,n=this.size[0]*this.size[1],a=r?Float32Array:Uint8Array,o=a.BYTES_PER_ELEMENT,l=s.byteLength/this.size[1];this.bandCount=Math.floor(l/o/this.size[0]);const h=Math.ceil(this.bandCount/4);if(1===h){const r=t.createTexture();return this.textures.push(r),void uploadDataTexture(e,r,s,this.size,this.bandCount,i.interpolate)}const T=new Array(h);for(let e=0;e<h;++e){const i=t.createTexture();this.textures.push(i);const s=e<h-1?4:this.bandCount%4;T[e]=new a(n*s)}let E=0,u=0;const d=this.size[0]*this.bandCount;for(let e=0;e<this.size[1];++e){for(let e=0;e<d;++e){const t=s[u+e],i=Math.floor(E/this.bandCount),r=e%this.bandCount,a=T[Math.floor(r/4)];a[i*(a.length/n)+r%4]=t,++E}u+=l/o}for(let t=0;t<h;++t){const s=this.textures[t],r=T[t],a=r.length/n;uploadDataTexture(e,s,r,this.size,a,i.interpolate)}}handleTileChange_(){this.tile.getState()===TileState.LOADED&&(this.loaded=!0,this.uploadTile_(),this.dispatchEvent(EventType.CHANGE))}disposeInternal(){const e=this.helper_.getGL();this.helper_.deleteBuffer(this.coords);for(let t=0;t<this.textures.length;++t)e.deleteTexture(this.textures[t]);this.tile.removeEventListener(EventType.CHANGE,this.handleTileChange_)}}export default TileTexture;
//# sourceMappingURL=/sm/af593a318407baa4b1ee88e2c3bb4ff5448c152c29b18a21df98030068e5804d.map