/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/ol@6.12.0/src/style/expressions.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import PaletteTexture from"../webgl/PaletteTexture.js";import{Uniforms}from"../renderer/webgl/TileLayer.js";import{asArray,fromString,isStringColor}from"../color.js";import{log2}from"../math.js";export const ValueTypes={NUMBER:1,STRING:2,COLOR:4,BOOLEAN:8,NUMBER_ARRAY:16,ANY:31,NONE:0};export const Operators={};export function getValueType(e){if("number"==typeof e)return ValueTypes.NUMBER;if("boolean"==typeof e)return ValueTypes.BOOLEAN;if("string"==typeof e)return isStringColor(e)?ValueTypes.COLOR|ValueTypes.STRING:ValueTypes.STRING;if(!Array.isArray(e))throw new Error(`Unhandled value type: ${JSON.stringify(e)}`);const t=e;if(t.every((function(e){return"number"==typeof e})))return 3===t.length||4===t.length?ValueTypes.COLOR|ValueTypes.NUMBER_ARRAY:ValueTypes.NUMBER_ARRAY;if("string"!=typeof t[0])throw new Error(`Expected an expression operator but received: ${JSON.stringify(t)}`);const r=Operators[t[0]];if(void 0===r)throw new Error(`Unrecognized expression operator: ${JSON.stringify(t)}`);return r.getReturnType(t.slice(1))}export function isTypeUnique(e){return log2(e)%1==0}export function numberToGlsl(e){const t=e.toString();return-1===t.indexOf(".")?t+".0":t}export function arrayToGlsl(e){if(e.length<2||e.length>4)throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");return`vec${e.length}(${e.map(numberToGlsl).join(", ")})`}export function colorToGlsl(e){const t=asArray(e).slice();return t.length<4&&t.push(1),arrayToGlsl(t.map((function(e,t){return t<3?e/255:e})))}export function getStringNumberEquivalent(e,t){return void 0===e.stringLiteralsMap[t]&&(e.stringLiteralsMap[t]=Object.keys(e.stringLiteralsMap).length),e.stringLiteralsMap[t]}export function stringToGlsl(e,t){return numberToGlsl(getStringNumberEquivalent(e,t))}export function expressionToGlsl(e,t,r){if(Array.isArray(t)&&"string"==typeof t[0]){const s=Operators[t[0]];if(void 0===s)throw new Error(`Unrecognized expression operator: ${JSON.stringify(t)}`);return s.toGlsl(e,t.slice(1),r)}const s=getValueType(t);if((s&ValueTypes.NUMBER)>0)return numberToGlsl(t);if((s&ValueTypes.BOOLEAN)>0)return t.toString();if((s&ValueTypes.STRING)>0&&(void 0===r||r==ValueTypes.STRING))return stringToGlsl(e,t.toString());if((s&ValueTypes.COLOR)>0&&(void 0===r||r==ValueTypes.COLOR))return colorToGlsl(t);if((s&ValueTypes.NUMBER_ARRAY)>0)return arrayToGlsl(t);throw new Error(`Unexpected expression ${t} (expected type ${r})`)}function assertNumber(e){if(!(getValueType(e)&ValueTypes.NUMBER))throw new Error(`A numeric value was expected, got ${JSON.stringify(e)} instead`)}function assertNumbers(e){for(let t=0;t<e.length;t++)assertNumber(e[t])}function assertString(e){if(!(getValueType(e)&ValueTypes.STRING))throw new Error(`A string value was expected, got ${JSON.stringify(e)} instead`)}function assertBoolean(e){if(!(getValueType(e)&ValueTypes.BOOLEAN))throw new Error(`A boolean value was expected, got ${JSON.stringify(e)} instead`)}function assertArgsCount(e,t){if(e.length!==t)throw new Error(`Exactly ${t} arguments were expected, got ${e.length} instead`)}function assertArgsMinCount(e,t){if(e.length<t)throw new Error(`At least ${t} arguments were expected, got ${e.length} instead`)}function assertArgsMaxCount(e,t){if(e.length>t)throw new Error(`At most ${t} arguments were expected, got ${e.length} instead`)}function assertArgsEven(e){if(e.length%2!=0)throw new Error(`An even amount of arguments was expected, got ${e} instead`)}function assertArgsOdd(e){if(e.length%2==0)throw new Error(`An odd amount of arguments was expected, got ${e} instead`)}function assertUniqueInferredType(e,t){if(!isTypeUnique(t))throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(e)}`)}Operators.get={getReturnType:function(e){return ValueTypes.ANY},toGlsl:function(e,t){assertArgsCount(t,1),assertString(t[0]);const r=t[0].toString();-1===e.attributes.indexOf(r)&&e.attributes.push(r);return(e.inFragmentShader?"v_":"a_")+r}};export function uniformNameForVariable(e){return"u_var_"+e}Operators.var={getReturnType:function(e){return ValueTypes.ANY},toGlsl:function(e,t){assertArgsCount(t,1),assertString(t[0]);const r=t[0].toString();return-1===e.variables.indexOf(r)&&e.variables.push(r),uniformNameForVariable(r)}};export const PALETTE_TEXTURE_ARRAY="u_paletteTextures";Operators.palette={getReturnType:function(e){return ValueTypes.COLOR},toGlsl:function(e,t){assertArgsCount(t,2),assertNumber(t[0]);const r=expressionToGlsl(e,t[0]),s=t[1];if(!Array.isArray(s))throw new Error("The second argument of palette must be an array");const n=s.length,o=new Uint8Array(4*n);for(let e=0;e<n;e++){const t=s[e];let r;if("string"==typeof t)r=fromString(t);else{if(!Array.isArray(t))throw new Error("The second argument of palette must be an array of strings or colors");const e=t.length;if(4===e)r=t;else{if(3!==e)throw new Error(`Expected palette color to have 3 or 4 values, got ${e}`);r=[t[0],t[1],t[2],1]}}const n=4*e;o[n]=r[0],o[n+1]=r[1],o[n+2]=r[2],o[n+3]=255*r[3]}e.paletteTextures||(e.paletteTextures=[]);const l=`u_paletteTextures[${e.paletteTextures.length}]`,u=new PaletteTexture(l,o);return e.paletteTextures.push(u),`texture2D(${l}, vec2((${r} + 0.5) / ${n}.0, 0.5))`}};const GET_BAND_VALUE_FUNC="getBandValue";function getEqualOperator(e){return{getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(t,r){assertArgsCount(r,2);let s=ValueTypes.ANY;for(let e=0;e<r.length;e++)s&=getValueType(r[e]);if(s===ValueTypes.NONE)throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(r)} instead`);return s&=~ValueTypes.COLOR,`(${expressionToGlsl(t,r[0],s)} ${e} ${expressionToGlsl(t,r[1],s)})`}}}function getDecisionOperator(e){return{getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(t,r){assertArgsMinCount(r,2);for(let e=0;e<r.length;e++)assertBoolean(r[e]);let s="";return s=r.map((e=>expressionToGlsl(t,e))).join(` ${e} `),s=`(${s})`,s}}}Operators.band={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){assertArgsMinCount(t,1),assertArgsMaxCount(t,3);const r=t[0];if(!("getBandValue"in e.functions)){let t="";const r=e.bandCount||1;for(let e=0;e<r;e++){const s=Math.floor(e/4);let n=e%4;n===r-1&&1===n&&(n=3);t+=`\n          if (band == ${e+1}.0) {\n            return texture2D(${`${Uniforms.TILE_TEXTURE_ARRAY}[${s}]`}, v_textureCoord + vec2(dx, dy))[${n}];\n          }\n        `}e.functions.getBandValue=`\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${t}\n        }\n      `}return`getBandValue(${expressionToGlsl(e,r)}, ${expressionToGlsl(e,t[1]||0)}, ${expressionToGlsl(e,t[2]||0)})`}},Operators.time={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_time"}},Operators.zoom={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_zoom"}},Operators.resolution={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,0),"u_resolution"}},Operators["*"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} * ${expressionToGlsl(e,t[1])})`}},Operators["/"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} / ${expressionToGlsl(e,t[1])})`}},Operators["+"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} + ${expressionToGlsl(e,t[1])})`}},Operators["-"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} - ${expressionToGlsl(e,t[1])})`}},Operators.clamp={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){assertArgsCount(t,3),assertNumbers(t);const r=expressionToGlsl(e,t[1]),s=expressionToGlsl(e,t[2]);return`clamp(${expressionToGlsl(e,t[0])}, ${r}, ${s})`}},Operators["%"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`mod(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`}},Operators["^"]={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`pow(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`}},Operators.abs={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`abs(${expressionToGlsl(e,t[0])})`}},Operators.sin={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`sin(${expressionToGlsl(e,t[0])})`}},Operators.cos={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsCount(t,1),assertNumbers(t),`cos(${expressionToGlsl(e,t[0])})`}},Operators.atan={getReturnType:function(e){return ValueTypes.NUMBER},toGlsl:function(e,t){return assertArgsMinCount(t,1),assertArgsMaxCount(t,2),assertNumbers(t),2===t.length?`atan(${expressionToGlsl(e,t[0])}, ${expressionToGlsl(e,t[1])})`:`atan(${expressionToGlsl(e,t[0])})`}},Operators[">"]={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} > ${expressionToGlsl(e,t[1])})`}},Operators[">="]={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} >= ${expressionToGlsl(e,t[1])})`}},Operators["<"]={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} < ${expressionToGlsl(e,t[1])})`}},Operators["<="]={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,2),assertNumbers(t),`(${expressionToGlsl(e,t[0])} <= ${expressionToGlsl(e,t[1])})`}},Operators["=="]=getEqualOperator("=="),Operators["!="]=getEqualOperator("!="),Operators["!"]={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){return assertArgsCount(t,1),assertBoolean(t[0]),`(!${expressionToGlsl(e,t[0])})`}},Operators.all=getDecisionOperator("&&"),Operators.any=getDecisionOperator("||"),Operators.between={getReturnType:function(e){return ValueTypes.BOOLEAN},toGlsl:function(e,t){assertArgsCount(t,3),assertNumbers(t);const r=expressionToGlsl(e,t[1]),s=expressionToGlsl(e,t[2]),n=expressionToGlsl(e,t[0]);return`(${n} >= ${r} && ${n} <= ${s})`}},Operators.array={getReturnType:function(e){return ValueTypes.NUMBER_ARRAY},toGlsl:function(e,t){assertArgsMinCount(t,2),assertArgsMaxCount(t,4),assertNumbers(t);const r=t.map((function(t){return expressionToGlsl(e,t,ValueTypes.NUMBER)}));return`vec${t.length}(${r.join(", ")})`}},Operators.color={getReturnType:function(e){return ValueTypes.COLOR},toGlsl:function(e,t){assertArgsMinCount(t,3),assertArgsMaxCount(t,4),assertNumbers(t);const r=t;3===t.length&&r.push(1);const s=t.map((function(t,r){return expressionToGlsl(e,t,ValueTypes.NUMBER)+(r<3?" / 255.0":"")}));return`vec${t.length}(${s.join(", ")})`}},Operators.interpolate={getReturnType:function(e){let t=ValueTypes.COLOR|ValueTypes.NUMBER;for(let r=3;r<e.length;r+=2)t&=getValueType(e[r]);return t},toGlsl:function(e,t,r){assertArgsEven(t),assertArgsMinCount(t,6);const s=t[0];let n;switch(s[0]){case"linear":n=1;break;case"exponential":n=s[1];break;default:n=null}if(!n)throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(s)}`);const o=void 0!==r?r:ValueTypes.ANY,l=Operators.interpolate.getReturnType(t)&o;assertUniqueInferredType(t,l);const u=expressionToGlsl(e,t[1]),a=numberToGlsl(n);let i="";for(let r=2;r<t.length-2;r+=2){const s=expressionToGlsl(e,t[r]),n=i||expressionToGlsl(e,t[r+1],l),o=expressionToGlsl(e,t[r+2]);i=`mix(${n}, ${expressionToGlsl(e,t[r+3],l)}, pow(clamp((${u} - ${s}) / (${o} - ${s}), 0.0, 1.0), ${a}))`}return i}},Operators.match={getReturnType:function(e){let t=ValueTypes.ANY;for(let r=2;r<e.length;r+=2)t&=getValueType(e[r]);return t&=getValueType(e[e.length-1]),t},toGlsl:function(e,t,r){assertArgsEven(t),assertArgsMinCount(t,4);const s=void 0!==r?r:ValueTypes.ANY,n=Operators.match.getReturnType(t)&s;assertUniqueInferredType(t,n);const o=expressionToGlsl(e,t[0]),l=expressionToGlsl(e,t[t.length-1],n);let u=null;for(let r=t.length-3;r>=1;r-=2){u=`(${o} == ${expressionToGlsl(e,t[r])} ? ${expressionToGlsl(e,t[r+1],n)} : ${u||l})`}return u}},Operators.case={getReturnType:function(e){let t=ValueTypes.ANY;for(let r=1;r<e.length;r+=2)t&=getValueType(e[r]);return t&=getValueType(e[e.length-1]),t},toGlsl:function(e,t,r){assertArgsOdd(t),assertArgsMinCount(t,3);const s=void 0!==r?r:ValueTypes.ANY,n=Operators.case.getReturnType(t)&s;assertUniqueInferredType(t,n);for(let e=0;e<t.length-1;e+=2)assertBoolean(t[e]);const o=expressionToGlsl(e,t[t.length-1],n);let l=null;for(let r=t.length-3;r>=0;r-=2){l=`(${expressionToGlsl(e,t[r])} ? ${expressionToGlsl(e,t[r+1],n)} : ${l||o})`}return l}};
//# sourceMappingURL=/sm/0429e8dccb64bb325d1eb46d38fb2b51b933668e85e7c35ab04cccdfe87008e5.map